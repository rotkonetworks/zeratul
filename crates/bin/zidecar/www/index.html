<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>zafu | zcash wallet</title>
<meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
<meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --bg: #0d0d12;
  --surface: #16161d;
  --border: #2a2a35;
  --gold: #f4a31e;
  --text: #e0e0e4;
  --dim: #707078;
  --ok: #50c878;
  --err: #c05050;
}
body {
  background: var(--bg);
  color: var(--text);
  font-family: 'SF Mono', 'Consolas', monospace;
  font-size: 13px;
  line-height: 1.6;
  padding: 24px;
  min-height: 100vh;
}
.container {
  max-width: 700px;
  margin: 0 auto;
}
h1 {
  color: var(--gold);
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 24px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border);
}
.section {
  margin-bottom: 24px;
  padding: 16px;
  background: var(--surface);
  border: 1px solid var(--border);
}
.section-title {
  color: var(--dim);
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 12px;
}
.row {
  display: flex;
  gap: 12px;
  align-items: center;
  margin-bottom: 8px;
}
.row:last-child { margin-bottom: 0; }
input, textarea, select {
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  padding: 8px 12px;
  font-family: inherit;
  font-size: 12px;
  flex: 1;
}
input:focus, textarea:focus {
  outline: none;
  border-color: var(--gold);
}
textarea { min-height: 60px; resize: vertical; }
button {
  background: var(--gold);
  color: #000;
  border: none;
  padding: 8px 16px;
  font-family: inherit;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  cursor: pointer;
}
button:hover { filter: brightness(1.1); }
button:disabled { background: var(--border); color: var(--dim); cursor: not-allowed; }
.status {
  padding: 12px;
  background: var(--bg);
  border-left: 3px solid var(--border);
  font-size: 12px;
  white-space: pre-wrap;
  word-wrap: break-word;
  min-height: 40px;
}
.status.ok { border-color: var(--ok); }
.status.err { border-color: var(--err); }
.status.active { border-color: var(--gold); }
.progress-bar {
  height: 8px;
  background: var(--bg);
  margin: 12px 0;
  overflow: hidden;
  position: relative;
}
.progress-fill {
  height: 100%;
  background: var(--gold);
  width: 0%;
  transition: width 0.2s;
  position: absolute;
  top: 0;
  left: 0;
}
.progress-verified {
  height: 100%;
  background: var(--ok);
  width: 0%;
  transition: width 0.2s;
  position: absolute;
  top: 0;
  left: 0;
}
.progress-legend {
  display: flex;
  gap: 16px;
  font-size: 10px;
  margin-top: 4px;
}
.progress-legend span::before {
  content: '';
  display: inline-block;
  width: 8px;
  height: 8px;
  margin-right: 4px;
  vertical-align: middle;
}
.legend-synced::before { background: var(--gold); }
.legend-verified::before { background: var(--ok); }
.balance {
  font-size: 28px;
  font-weight: 600;
  color: var(--gold);
  text-align: center;
  padding: 20px;
}
.balance span { font-size: 14px; color: var(--dim); }
.info-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  font-size: 12px;
}
.info-grid .label { color: var(--dim); }
.info-grid .value { text-align: right; }
.hidden { display: none; }
.note-list {
  max-height: 150px;
  overflow-y: auto;
  font-size: 11px;
}
.note {
  padding: 6px 0;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
}
.note:last-child { border-bottom: none; }
.note.spent { opacity: 0.5; }
.note .amount { color: var(--ok); }
.note.spent .amount { color: var(--err); }
.security-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}
.security-layer {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  background: var(--bg);
  border-left: 2px solid var(--border);
}
.security-layer.active { border-color: var(--gold); }
.security-layer.verified { border-color: var(--ok); }
.security-layer.unavailable { opacity: 0.5; }
.sec-icon {
  font-size: 16px;
  width: 20px;
  text-align: center;
  color: var(--dim);
}
.security-layer.active .sec-icon,
.security-layer.verified .sec-icon { color: var(--gold); }
.sec-info { flex: 1; min-width: 0; }
.sec-name { font-size: 11px; font-weight: 600; }
.sec-desc { font-size: 9px; color: var(--dim); }
.sec-status {
  font-size: 9px;
  color: var(--dim);
  text-align: right;
  white-space: nowrap;
}
.security-layer.verified .sec-status { color: var(--ok); }
.proof-details {
  margin-top: 12px;
  padding: 10px;
  background: var(--bg);
  font-size: 11px;
}
.proof-title {
  color: var(--dim);
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}
.proof-grid {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 4px 12px;
}
.proof-grid .label { color: var(--dim); }
.proof-grid .value { text-align: right; font-family: monospace; }
.proof-grid .value.hash { font-size: 10px; overflow: hidden; text-overflow: ellipsis; }
.proof-grid .value.ok { color: var(--ok); }
.proof-grid .value.err { color: var(--err); }
</style>
</head>
<body>
<div class="container">
<h1>zafu <span style="color: var(--dim); font-weight: 400">zcash light wallet</span></h1>

<div class="section">
  <div class="section-title">server</div>
  <div class="row">
    <input type="text" id="server-url" value="http://localhost:50051" placeholder="zidecar server">
    <button id="connect-btn">connect</button>
  </div>
  <div class="status" id="connect-status">not connected</div>
</div>

<div class="section hidden" id="wallet-section">
  <div class="section-title">wallet</div>
  <div class="row">
    <textarea id="seed-phrase" placeholder="enter 24-word seed phrase"></textarea>
  </div>
  <div class="row">
    <input type="number" id="birthday" value="1687104" min="1" placeholder="birthday height">
    <button id="import-btn">import</button>
  </div>
  <div class="status" id="wallet-status">enter seed phrase (orchard only)</div>
</div>

<div class="section hidden" id="sync-section">
  <div class="section-title">sync</div>
  <div class="info-grid" id="sync-info" style="grid-template-columns: 1fr 1fr 1fr 1fr;">
    <span class="label">chain tip</span><span class="value" id="chain-height">-</span>
    <span class="label">proven to</span><span class="value" id="proven-height" style="color: var(--ok)">-</span>
    <span class="label">scan from</span><span class="value" id="birthday-height">-</span>
    <span class="label">scanned to</span><span class="value" id="wallet-height">-</span>
  </div>
  <div class="progress-bar">
    <div class="progress-verified" id="progress-verified"></div>
    <div class="progress-fill" id="progress"></div>
  </div>
  <div class="progress-legend">
    <span class="legend-verified">proven (genesis→tip)</span>
    <span class="legend-synced">scanned (birthday→tip)</span>
  </div>
  <div class="row">
    <button id="sync-btn">sync</button>
    <button id="stop-btn" class="hidden">stop</button>
  </div>
  <div class="status" id="sync-status">ready to sync</div>
</div>

<div class="section hidden" id="security-section">
  <div class="section-title">security layers</div>
  <div class="security-grid" style="grid-template-columns: 1fr 1fr 1fr;">
    <div class="security-layer" id="sec-ligerito">
      <div class="sec-icon">◈</div>
      <div class="sec-info">
        <div class="sec-name">Ligerito</div>
        <div class="sec-desc">header chain ZKP</div>
      </div>
      <div class="sec-status" id="sec-ligerito-status">-</div>
    </div>
    <div class="security-layer" id="sec-zanchor">
      <div class="sec-icon">●</div>
      <div class="sec-info">
        <div class="sec-name">Zanchor</div>
        <div class="sec-desc">polkadot finality</div>
      </div>
      <div class="sec-status" id="sec-zanchor-status">-</div>
    </div>
    <div class="security-layer" id="sec-nomt">
      <div class="sec-icon">⌘</div>
      <div class="sec-info">
        <div class="sec-name">NOMT</div>
        <div class="sec-desc">state proof</div>
      </div>
      <div class="sec-status" id="sec-nomt-status">-</div>
    </div>
  </div>
  <div class="proof-details hidden" id="proof-details">
    <div class="proof-title">proof verification</div>
    <div class="proof-grid">
      <span class="label">proven range</span><span class="value" id="proof-giga-range">-</span>
      <span class="label">tip hash</span><span class="value hash" id="proof-tip-hash">-</span>
      <span class="label">chain work</span><span class="value" id="proof-work">-</span>
      <span class="label">continuity</span><span class="value" id="proof-continuity">-</span>
      <span class="label">NOMT root</span><span class="value hash" id="proof-nomt-root">-</span>
      <span class="label">state epoch</span><span class="value" id="proof-state-epoch">-</span>
    </div>
  </div>
</div>

<div class="section hidden" id="balance-section">
  <div class="section-title">balance</div>
  <div class="balance" id="balance">0.00000000 <span>ZEC</span></div>
  <div class="note-list" id="notes"></div>
</div>

</div>

<script type="module">
import initWasm, { WalletKeys, validate_seed_phrase, version, num_threads } from './pkg/zafu_wasm.js';
import * as zafuWasm from './pkg/zafu_wasm.js';
import initLigerito, { verify as verifyProof } from './ligerito.js';
import * as ligerito from './ligerito.js';
import { signal, computed, effect, batch, bindText, bindStyle, bindVisible, varint, bytesToHex, formatNumber, formatZec } from './utils.js';

const $ = id => document.getElementById(id);

// ============== REACTIVE STATE ==============
const [connected, setConnected] = signal(false);
const [serverUrl, setServerUrl] = signal('');
const [chainHeight, setChainHeight] = signal(0);
const [birthday, setBirthday] = signal(0);
const [walletHeight, setWalletHeight] = signal(0);
const [scanning, setScanning] = signal(false);
const [notes, setNotes] = signal([]);
const [spent, setSpent] = signal([]);
const [gigaproofHeight, setGigaproofHeight] = signal(0);
const [verifiedHeight, setVerifiedHeight] = signal(0);
const [proofsVerified, setProofsVerified] = signal(0);
const [nullifiersObserved, setNullifiersObserved] = signal(0);
const [serverNullifierRoot, setServerNullifierRoot] = signal(null);
const [syncStatus, setSyncStatus] = signal('ready to sync');
const [syncStatusClass, setSyncStatusClass] = signal('');
const [connectStatus, setConnectStatus] = signal('not connected');
const [connectStatusClass, setConnectStatusClass] = signal('');
const [walletStatus, setWalletStatus] = signal('enter seed phrase (orchard only)');
const [walletStatusClass, setWalletStatusClass] = signal('');
const [walletKeys, setWalletKeys] = signal(null);

// Security layer signals - start with 'pending' so users know verification is expected
const [ligeritoStatus, setLigeritoStatus] = signal('active');
const [ligeritoDetail, setLigeritoDetail] = signal('pending');
const [zanchorStatus, setZanchorStatus] = signal('none');
const [zanchorDetail, setZanchorDetail] = signal('checking...');
const [nomtStatus, setNomtStatus] = signal('active');
const [nomtDetail, setNomtDetail] = signal('pending');

// Proof details signals
const [proofRange, setProofRange] = signal('-');
const [proofTipHash, setProofTipHash] = signal('-');
const [proofWork, setProofWork] = signal('-');
const [proofContinuity, setProofContinuity] = signal('-');
const [proofContinuityClass, setProofContinuityClass] = signal('value');
const [proofNomtRoot, setProofNomtRoot] = signal('-');
const [proofNomtRootClass, setProofNomtRootClass] = signal('value hash');
const [proofStateEpoch, setProofStateEpoch] = signal('-');
const [showProofDetails, setShowProofDetails] = signal(false);

// Computed values
const provenHeight = computed(() => {
  const v = verifiedHeight();
  const g = gigaproofHeight();
  return v > g ? v : g;
});

const provenHeightText = computed(() => {
  const h = provenHeight();
  return h > 0 ? h.toLocaleString() : '-';
});

const chainHeightText = computed(() => {
  const h = chainHeight();
  return h > 0 ? h.toLocaleString() : '-';
});

const walletHeightText = computed(() => {
  const h = walletHeight();
  return h > 0 ? h.toLocaleString() : '-';
});

const birthdayText = computed(() => {
  const b = birthday();
  return b > 0 ? b.toLocaleString() : '-';
});

const scanProgress = computed(() => {
  const b = birthday();
  const w = walletHeight();
  const c = chainHeight();
  if (c <= b) return '0%';
  return ((w - b) / (c - b) * 100) + '%';
});

const verifiedProgress = computed(() => {
  const p = provenHeight();
  const c = chainHeight();
  if (c === 0) return '0%';
  return Math.min(100, (p / c * 100)) + '%';
});

const balance = computed(() => {
  const n = notes();
  const s = spent();
  const unspent = n.filter(note => !s.includes(note.nullifier));
  const bal = unspent.reduce((sum, note) => sum + BigInt(note.value), 0n);
  return (Number(bal) / 1e8).toFixed(8);
});

// Computed visibility states
const hasWallet = computed(() => walletKeys() !== null);
const showWalletSection = computed(() => connected());
const showSyncSection = computed(() => hasWallet());
const showBalanceSection = computed(() => hasWallet());
// Show security section when syncing, or when we have verified proofs, or when gigaproof is available
const showSecuritySection = computed(() => hasWallet() && (scanning() || proofsVerified() > 0 || gigaproofHeight() > 0));

// ============== REACTIVE BINDINGS ==============
function setupBindings() {
  // Status displays with dynamic classes
  effect(() => {
    $('connect-status').textContent = connectStatus();
    $('connect-status').className = 'status' + (connectStatusClass() ? ' ' + connectStatusClass() : '');
  });

  effect(() => {
    $('wallet-status').textContent = walletStatus();
    $('wallet-status').className = 'status' + (walletStatusClass() ? ' ' + walletStatusClass() : '');
  });

  effect(() => {
    $('sync-status').textContent = syncStatus();
    $('sync-status').className = 'status' + (syncStatusClass() ? ' ' + syncStatusClass() : '');
  });

  // Height displays - auto-update
  bindText('chain-height', chainHeightText);
  bindText('proven-height', provenHeightText);
  bindText('birthday-height', birthdayText);
  bindText('wallet-height', walletHeightText);

  // Progress bars - auto-update
  bindStyle('progress', 'width', scanProgress);
  bindStyle('progress-verified', 'width', verifiedProgress);

  // Section visibility - auto-update
  bindVisible('wallet-section', showWalletSection);
  bindVisible('sync-section', showSyncSection);
  bindVisible('balance-section', showBalanceSection);
  bindVisible('security-section', showSecuritySection);
  bindVisible('proof-details', showProofDetails);

  // Sync/stop button visibility
  effect(() => {
    if (scanning()) {
      $('sync-btn').classList.add('hidden');
      $('stop-btn').classList.remove('hidden');
    } else {
      $('sync-btn').classList.remove('hidden');
      $('stop-btn').classList.add('hidden');
    }
  });

  // Balance display - auto-update
  effect(() => {
    $('balance').innerHTML = balance() + ' <span>ZEC</span>';
  });

  // Notes list - auto-update
  effect(() => {
    const n = notes();
    const s = spent();
    const list = $('notes');

    if (n.length === 0) {
      list.innerHTML = '<div style="color: var(--dim); padding: 8px;">no notes found</div>';
    } else {
      list.innerHTML = n.map(note => {
        const isSpent = s.includes(note.nullifier);
        const val = (Number(note.value) / 1e8).toFixed(8);
        return `<div class="note ${isSpent ? 'spent' : ''}">
          <span>#${note.height}</span>
          <span class="amount">${isSpent ? '-' : '+'}${val}</span>
        </div>`;
      }).join('');
    }
  });

  // Security layers - auto-update with fine-grained reactivity
  effect(() => {
    const el = $('sec-ligerito');
    el.classList.remove('active', 'verified', 'unavailable');
    const s = ligeritoStatus();
    if (s === 'active') el.classList.add('active');
    else if (s === 'verified') el.classList.add('verified');
    else if (s === 'unavailable') el.classList.add('unavailable');
    $('sec-ligerito-status').textContent = ligeritoDetail();
  });

  effect(() => {
    const el = $('sec-zanchor');
    el.classList.remove('active', 'verified', 'unavailable');
    const s = zanchorStatus();
    if (s === 'active') el.classList.add('active');
    else if (s === 'verified') el.classList.add('verified');
    else if (s === 'unavailable') el.classList.add('unavailable');
    $('sec-zanchor-status').textContent = zanchorDetail();
  });

  effect(() => {
    const el = $('sec-nomt');
    el.classList.remove('active', 'verified', 'unavailable');
    const s = nomtStatus();
    if (s === 'active') el.classList.add('active');
    else if (s === 'verified') el.classList.add('verified');
    else if (s === 'unavailable') el.classList.add('unavailable');
    $('sec-nomt-status').textContent = nomtDetail();
  });

  // Proof details - auto-update
  bindText('proof-giga-range', proofRange);
  effect(() => {
    $('proof-tip-hash').textContent = proofTipHash();
    $('proof-tip-hash').title = proofTipHash();
  });
  bindText('proof-work', proofWork);
  effect(() => {
    $('proof-continuity').textContent = proofContinuity();
    $('proof-continuity').className = proofContinuityClass();
  });
  effect(() => {
    $('proof-nomt-root').textContent = proofNomtRoot();
    $('proof-nomt-root').className = proofNomtRootClass();
  });
  bindText('proof-state-epoch', proofStateEpoch);
}

// Init WASM
async function init() {
  // Set up reactive bindings FIRST so UI updates work
  setupBindings();

  setConnectStatus('loading wasm...');

  try {
    await Promise.all([initWasm(), initLigerito()]);
    const threads = navigator.hardwareConcurrency || 4;
    try {
      const poolInits = [];
      if (zafuWasm.initThreadPool) poolInits.push(zafuWasm.initThreadPool(threads));
      if (ligerito.initThreadPool) poolInits.push(ligerito.initThreadPool(threads));
      if (poolInits.length > 0) await Promise.all(poolInits);
    } catch (e) {
      console.warn('thread pool failed:', e);
    }
    setConnectStatus(`zafu ${version()} ready (${num_threads()} threads)`);
  } catch (e) {
    setConnectStatus('wasm failed: ' + e.message);
    setConnectStatusClass('err');
  }
}

// Connect
$('connect-btn').onclick = async () => {
  const url = $('server-url').value.trim();
  setConnectStatus('connecting...');
  setConnectStatusClass('active');

  try {
    const resp = await grpc(url, 'GetSyncStatus', {});

    batch(() => {
      setConnected(true);
      setServerUrl(url);
      setChainHeight(resp.currentHeight);
      setGigaproofHeight(resp.lastGigaproofHeight || 0);
    });

    const proofStatus = resp.lastGigaproofHeight > 0
      ? `proven to ${resp.lastGigaproofHeight.toLocaleString()}`
      : 'generating proof...';

    setConnectStatus(`connected - height ${resp.currentHeight.toLocaleString()}, ${proofStatus}`);
    setConnectStatusClass('ok');

    // Poll for updates and continuously verify new tip proofs
    setInterval(async () => {
      if (!connected()) return;
      try {
        const r = await grpc(serverUrl(), 'GetSyncStatus', {});
        const oldChainHeight = chainHeight();
        const newChainHeight = r.currentHeight;

        batch(() => {
          setChainHeight(newChainHeight);
          setGigaproofHeight(r.lastGigaproofHeight || 0);
        });

        // If chain advanced and we have verified proofs, verify new tip
        if (newChainHeight > oldChainHeight && proofsVerified() > 0 && !scanning()) {
          const currentVerified = verifiedHeight();
          if (newChainHeight > currentVerified) {
            console.log(`[poll] chain advanced ${oldChainHeight} -> ${newChainHeight}, verifying new tip...`);
            setLigeritoDetail('new tip...');

            // Fetch fresh proof covering up to new tip
            const proof = await fetchHeaderProof(1, newChainHeight);
            if (proof && proof.ligerito_proof?.length > 0) {
              const ok = await verifyHeaderProof(proof);
              if (ok) {
                // Update verified height from tip proof
                const tipEnd = proof.tip_proof_outputs?.end_height || newChainHeight;
                setVerifiedHeight(tipEnd);
                setProofsVerified(proofsVerified() + 1);
                setLigeritoDetail(`tip ${tipEnd.toLocaleString()} ✓`);
                updateProofDetails(proof);
                console.log(`[poll] continuous verification OK: ${tipEnd}`);
              }
            }
          }
        }
      } catch (e) {
        console.warn('[poll] error:', e);
      }
    }, 10000);  // Check every 10s

  } catch (e) {
    setConnectStatus('failed: ' + e.message);
    setConnectStatusClass('err');
  }
};

// Import wallet
$('import-btn').onclick = async () => {
  const seed = $('seed-phrase').value.trim();
  const birthdayHeight = parseInt($('birthday').value) || 1687104;

  if (!validate_seed_phrase(seed)) {
    setWalletStatus('invalid seed phrase');
    setWalletStatusClass('err');
    return;
  }

  try {
    const keys = new WalletKeys(seed);
    const addr = keys.get_address();

    batch(() => {
      setWalletKeys(keys);
      setWalletHeight(birthdayHeight);
      setBirthday(birthdayHeight);
      setNotes([]);
      setSpent([]);
    });

    setWalletStatus(`imported: ${addr.slice(0,16)}...`);
    setWalletStatusClass('ok');
    // UI updates automatically via bindings!

  } catch (e) {
    setWalletStatus('error: ' + e.message);
    setWalletStatusClass('err');
  }
};

// Sync
$('sync-btn').onclick = async () => {
  if (!walletKeys() || scanning()) return;

  setScanning(true);

  const start = walletHeight();
  const end = chainHeight();
  const total = end - start;

  if (total <= 0) {
    setSyncStatus('already synced');
    finishSync();
    return;
  }

  let scanned = 0;
  let actions = 0;
  let found = 0;
  const batchSize = 200;
  const startTime = performance.now();

  batch(() => {
    setSyncStatusClass('active');
    setVerifiedHeight(start);
    setProofsVerified(0);
    setNullifiersObserved(0);
  });

  console.log(`[sync] starting scan from ${start} to ${end} (${total} blocks)`);

  // Initialize security layers
  setSecurityLayer('ligerito', 'active', 'starting...');
  setSecurityLayer('zanchor', 'none', 'checking...');
  setSecurityLayer('nomt', 'active', 'scanning...');

  // Fetch checkpoint to check Zanchor (Polkadot) status
  try {
    const checkpoint = await fetchCheckpoint();
    if (checkpoint && checkpoint.epoch > 0) {
      setSecurityLayer('zanchor', 'verified', `epoch ${checkpoint.epoch}`);
    } else {
      setSecurityLayer('zanchor', 'unavailable', 'awaiting finality');
    }
  } catch (e) {
    console.warn('[checkpoint] fetch error:', e);
    setSecurityLayer('zanchor', 'unavailable', 'not connected');
  }

  // Start verification in background (non-blocking) while scanning blocks
  const currentGigaproofHeight = gigaproofHeight();
  console.log(`[verify] gigaproofHeight=${currentGigaproofHeight}, start=${start}`);

  if (currentGigaproofHeight > start) {
    const provenTo = Math.min(currentGigaproofHeight, end);
    setSecurityLayer('ligerito', 'active', 'fetching...');

    // Run verification in background - don't block block scanning
    (async () => {
      try {
        console.log(`[verify] starting background verification: fetching proof 1->${currentGigaproofHeight}...`);
        const headerProof = await fetchHeaderProof(1, currentGigaproofHeight);
        console.log(`[verify] fetchHeaderProof returned:`, headerProof ? `${headerProof.ligerito_proof?.length || 0} bytes` : 'null');

        if (headerProof && headerProof.ligerito_proof && headerProof.ligerito_proof.length > 0) {
          setSecurityLayer('ligerito', 'active', 'verifying...');
          const startVerify = performance.now();
          const ok = await verifyHeaderProofAndUpdate(headerProof, provenTo);
          const elapsed = ((performance.now() - startVerify) / 1000).toFixed(1);

          if (ok) {
            const status = buildVerifyStatus(headerProof, elapsed);
            setSecurityLayer('ligerito', 'verified', status);
            console.log(`[verify] background verification complete: ${status}`);
          } else {
            console.warn('[verify] verification failed');
            setSecurityLayer('ligerito', 'unavailable', 'failed');
          }
        } else {
          console.log('[verify] no proof data in response');
          setSecurityLayer('ligerito', 'active', 'awaiting proof...');
        }
      } catch (e) {
        console.error('[verify] background verify error:', e);
        setSecurityLayer('ligerito', 'unavailable', `error: ${e.message}`);
      }
    })();  // Fire and forget
  } else {
    console.log(`[verify] skipping verification: gigaproofHeight(${currentGigaproofHeight}) <= start(${start})`);
    setSecurityLayer('ligerito', 'active', 'awaiting proof...');
  }

  // Block scanning loop
  const keys = walletKeys();
  let currentNotes = [...notes()];
  let currentSpent = [...spent()];
  let nfCount = 0;

  for (let h = start; h <= end && scanning(); h += batchSize) {
    const batchEnd = Math.min(h + batchSize - 1, end);

    try {
      const blocks = await fetchBlocks(h, batchEnd);
      const batchActions = blocks.reduce((sum, b) => sum + b.actions.length, 0);
      if (batchActions > 0) {
        console.log(`[batch ${h}-${batchEnd}] ${blocks.length} blocks, ${batchActions} actions`);
      }

      for (const block of blocks) {
        if (!scanning()) break;  // Check stop flag

        actions += block.actions.length;

        // Build binary for parallel scan
        if (block.actions.length > 0 && keys) {
          const binary = buildBinaryActions(block.actions);
          try {
            const foundNotes = keys.scan_actions_parallel(binary);
            if (foundNotes && foundNotes.length > 0) {
              found += foundNotes.length;
              console.log(`[block ${block.height}] found ${foundNotes.length} notes!`, foundNotes);
              for (const n of foundNotes) {
                currentNotes.push({ ...n, height: block.height });
              }
            }
          } catch (e) {
            console.warn('scan error at block', block.height, ':', e);
          }
        }

        // Track nullifiers
        for (const a of block.actions) {
          if (a.nullifier && a.nullifier.length === 32) {
            nfCount++;
            const nf = bytesToHex(a.nullifier);
            if (currentNotes.find(n => n.nullifier === nf)) {
              currentSpent.push(nf);
            }
          }
        }

        setWalletHeight(block.height);
      }

      if (!scanning()) break;  // Exit outer loop too

      scanned += blocks.length;
      const scanPct = (scanned / total) * 100;
      const elapsed = (performance.now() - startTime) / 1000;
      const rate = Math.round(actions / elapsed);

      // Update state - signals handle UI updates
      batch(() => {
        setNullifiersObserved(nfCount);
        setNotes([...currentNotes]);
        setSpent([...currentSpent]);
      });

      setSyncStatus(`${scanPct.toFixed(1)}% | ${actions.toLocaleString()} actions (${rate}/s) | ${found} notes`);

    } catch (e) {
      setSyncStatus('error: ' + e.message);
      setSyncStatusClass('err');
      break;
    }

    // Yield to event loop
    await new Promise(r => setTimeout(r, 10));
  }

  // Check if we were stopped
  const wasStopped = !scanning();

  // At end, try to verify tip proof for blocks beyond gigaproof (if not stopped)
  if (!wasStopped && walletHeight() > gigaproofHeight()) {
    setSyncStatus('verifying tip proof...');
    try {
      const proof = await fetchHeaderProof(gigaproofHeight() + 1, walletHeight());
      if (proof && proof.ligerito_proof?.length > 0) {
        const ok = await verifyHeaderProofAndUpdate(proof, walletHeight());
        if (ok) {
          setProofsVerified(proofsVerified() + 1);
          console.log(`[verify] tip proof verified!`);
        }
      }
    } catch (e) {
      console.warn('[verify] tip proof failed:', e);
    }
  }

  finishSync(wasStopped);
};

$('stop-btn').onclick = () => {
  setScanning(false);
  setSyncStatus('stopping...');
  console.log('[sync] stop requested by user');
};

// Helper: set security layer via signals
function setSecurityLayer(layer, status, detail) {
  if (layer === 'ligerito') {
    setLigeritoStatus(status);
    setLigeritoDetail(detail || (status === 'verified' ? '✓' : '-'));
  } else if (layer === 'zanchor') {
    setZanchorStatus(status);
    setZanchorDetail(detail || (status === 'verified' ? '✓' : '-'));
  } else if (layer === 'nomt') {
    setNomtStatus(status);
    setNomtDetail(detail || (status === 'verified' ? '✓' : '-'));
  }
}

// Helper: verify proof and update signals
async function verifyHeaderProofAndUpdate(headerProof, fallbackHeight) {
  const ok = await verifyHeaderProof(headerProof);

  if (ok) {
    const continuityOk = headerProof.continuity_verified;
    const hasTip = headerProof.tip_proof_outputs !== null;

    // Determine actual proven height
    let actualProvenHeight = fallbackHeight;
    if (hasTip && continuityOk && headerProof.tip_proof_outputs.end_height > 0) {
      actualProvenHeight = headerProof.tip_proof_outputs.end_height;
    } else if (headerProof.gigaproof_outputs?.end_height > 0) {
      actualProvenHeight = headerProof.gigaproof_outputs.end_height;
    }

    // Log public outputs
    if (headerProof.gigaproof_outputs) {
      const go = headerProof.gigaproof_outputs;
      console.log(`[verify] gigaproof: ${go.start_height} -> ${go.end_height}, ${go.num_headers} headers`);
    }
    if (headerProof.tip_proof_outputs) {
      const to = headerProof.tip_proof_outputs;
      console.log(`[verify] tip_proof: ${to.start_height} -> ${to.end_height}, ${to.num_headers} headers`);
    }

    console.log(`[verify] proven height: ${actualProvenHeight} (fallback: ${fallbackHeight}, tip: ${headerProof.tip_proof_outputs?.end_height || 'none'})`);

    batch(() => {
      setVerifiedHeight(actualProvenHeight);
      setProofsVerified(proofsVerified() + 1);

      // Update NOMT status with nullifier root
      if (headerProof.nullifier_root && headerProof.nullifier_root.length === 32) {
        const nfRoot = bytesToHex(headerProof.nullifier_root);
        setServerNullifierRoot(nfRoot);
        setSecurityLayer('nomt', 'verified', `root: ${nfRoot.slice(0, 8)}...`);
      } else if (headerProof.gigaproof_outputs?.final_state_commitment) {
        setSecurityLayer('nomt', 'verified', 'state proven');
      }
    });

    updateProofDetails(headerProof);
  }

  return ok;
}

// Helper: build verify status string
function buildVerifyStatus(headerProof, elapsed) {
  const continuityOk = headerProof.continuity_verified;
  const hasTip = headerProof.tip_proof_outputs !== null;
  let status = `verified (${elapsed}s)`;
  if (hasTip) status += continuityOk ? ' ✓' : ' ⚠';
  return status;
}

async function finishSync(wasStopped = false) {
  const wasRunning = scanning();
  setScanning(false);
  setSyncStatusClass(wasStopped ? 'active' : 'ok');

  // If verification hasn't completed yet, try once more
  if (proofsVerified() === 0 && gigaproofHeight() > 0) {
    console.log('[finishSync] attempting proof verification...');
    setSecurityLayer('ligerito', 'active', 'verifying...');

    try {
      const headerProof = await fetchHeaderProof(1, gigaproofHeight());
      if (headerProof && headerProof.ligerito_proof && headerProof.ligerito_proof.length > 0) {
        const startVerify = performance.now();
        const ok = await verifyHeaderProofAndUpdate(headerProof, gigaproofHeight());
        const elapsed = ((performance.now() - startVerify) / 1000).toFixed(1);

        if (ok) {
          setSecurityLayer('ligerito', 'verified', buildVerifyStatus(headerProof, elapsed));
          console.log(`[finishSync] verification complete`);
        } else {
          setSecurityLayer('ligerito', 'unavailable', 'verify failed');
        }
      } else {
        setSecurityLayer('ligerito', 'active', 'no proof yet');
      }
    } catch (e) {
      console.error('[finishSync] verification error:', e);
      setSecurityLayer('ligerito', 'unavailable', 'error');
    }
  }

  // Show verification summary - computed provenHeight handles the logic
  const proofDesc = proofsVerified() > 0
    ? `chain proven (${proofsVerified()} zkp from genesis)`
    : 'chain verified';

  const nfCount = nullifiersObserved();
  const nfDesc = nfCount > 0 ? `, ${nfCount.toLocaleString()} nullifiers` : '';

  const statusPrefix = wasStopped ? 'stopped' : 'scan complete';
  setSyncStatus(`${statusPrefix} - ${proofDesc}${nfDesc}`);

  // Update NOMT status based on nullifier root availability
  const nfRoot = serverNullifierRoot();
  if (nfRoot) {
    setSecurityLayer('nomt', 'verified', `${nfCount.toLocaleString()} nfs`);
    console.log(`[nomt] verified: ${nfCount.toLocaleString()} nullifiers, root: ${nfRoot.slice(0, 8)}...`);
  } else if (proofsVerified() > 0) {
    setSecurityLayer('nomt', 'active', `${nfCount.toLocaleString()} nfs (no root)`);
  } else {
    setSecurityLayer('nomt', 'active', `${nfCount.toLocaleString()} nfs`);
  }
}

// Update proof details via signals - all reactive!
function updateProofDetails(headerProof) {
  const go = headerProof.gigaproof_outputs;
  const to = headerProof.tip_proof_outputs;

  setShowProofDetails(true);

  // Full proven range (gigaproof + tip if available)
  if (go) {
    const endHeight = (to && headerProof.continuity_verified) ? to.end_height : go.end_height;
    const totalHeaders = go.num_headers + (to?.num_headers || 0);
    const rangeInfo = to ? ` + ${to.num_headers.toLocaleString()} tip` : '';
    setProofRange(`${go.start_height.toLocaleString()} → ${endHeight.toLocaleString()} (${totalHeaders.toLocaleString()} headers${rangeInfo})`);
  }

  // Tip hash - use tip proof's tip_hash if available, else gigaproof's
  const actualTipHash = (to && headerProof.continuity_verified && to.tip_hash) ? to.tip_hash : go?.tip_hash;
  if (actualTipHash) {
    const tipHashHex = bytesToHex(actualTipHash);
    setProofTipHash(tipHashHex.slice(0, 16) + '...');
  }

  // Chain work (cumulative difficulty)
  if (go?.cumulative_difficulty) {
    const work = go.cumulative_difficulty;
    const formatted = work > 1000000000000n
      ? `${(Number(work) / 1e12).toFixed(2)}T`
      : work > 1000000000n
      ? `${(Number(work) / 1e9).toFixed(2)}B`
      : work.toLocaleString();
    setProofWork(formatted);
  }

  // Continuity verification
  if (to) {
    if (headerProof.continuity_verified) {
      setProofContinuity('✓ giga→tip linked');
      setProofContinuityClass('value ok');
    } else {
      setProofContinuity('✗ chain break!');
      setProofContinuityClass('value err');
    }
  } else {
    setProofContinuity('single proof');
    setProofContinuityClass('value');
  }

  // NOMT nullifier root
  if (headerProof.nullifier_root && headerProof.nullifier_root.length === 32) {
    const rootHex = bytesToHex(headerProof.nullifier_root);
    setProofNomtRoot(rootHex.slice(0, 16) + '...');
    setProofNomtRootClass('value hash ok');
    setServerNullifierRoot(rootHex);
    setSecurityLayer('nomt', 'verified', 'root verified');
    console.log(`[nomt] server nullifier root: ${rootHex.slice(0, 16)}...`);
  } else if (go?.final_state_commitment) {
    const rootHex = bytesToHex(go.final_state_commitment);
    setProofNomtRoot(rootHex.slice(0, 16) + '...');
    setProofNomtRootClass('value hash');
  } else {
    setProofNomtRoot('not available');
    setProofNomtRootClass('value hash');
  }

  // Epoch = end_height / 1024
  if (go?.end_height) {
    const epoch = Math.floor(go.end_height / 1024);
    setProofStateEpoch(`epoch ${epoch.toLocaleString()}`);
  } else {
    setProofStateEpoch('-');
  }
}

// Balance and notes are computed reactively via effects in setupBindings()
// No manual updateBalance() needed anymore!

// gRPC helpers
async function grpc(url, method, data) {
  const path = `${url}/zidecar.v1.Zidecar/${method}`;
  let body;

  if (method === 'GetSyncStatus' || method === 'GetTip') {
    body = new Uint8Array([0, 0, 0, 0, 0]);
  } else {
    throw new Error('unsupported method');
  }

  const resp = await fetch(path, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/grpc-web+proto',
      'Accept': 'application/grpc-web+proto',
      'x-grpc-web': '1',
    },
    body,
  });

  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

  const buf = new Uint8Array(await resp.arrayBuffer());
  if (buf.length < 5) throw new Error('empty response');

  const len = (buf[1] << 24) | (buf[2] << 16) | (buf[3] << 8) | buf[4];
  const msg = buf.slice(5, 5 + len);

  if (method === 'GetSyncStatus') return parseSyncStatus(msg);
  return {};
}

async function fetchBlocks(start, end) {
  const path = `${serverUrl()}/zidecar.v1.Zidecar/GetCompactBlocks`;
  console.log(`[fetch] requesting blocks ${start}-${end}`);

  // Encode BlockRange
  const parts = [];
  if (start > 0) { parts.push(0x08); parts.push(...varint(start)); }
  if (end > 0) { parts.push(0x10); parts.push(...varint(end)); }
  const msg = new Uint8Array(parts);

  const body = new Uint8Array(5 + msg.length);
  body[0] = 0;
  body[1] = (msg.length >> 24) & 0xff;
  body[2] = (msg.length >> 16) & 0xff;
  body[3] = (msg.length >> 8) & 0xff;
  body[4] = msg.length & 0xff;
  body.set(msg, 5);

  const resp = await fetch(path, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/grpc-web+proto',
      'Accept': 'application/grpc-web+proto',
      'x-grpc-web': '1',
    },
    body,
  });

  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

  const buf = new Uint8Array(await resp.arrayBuffer());
  const blocks = parseBlockStream(buf);
  const totalActions = blocks.reduce((sum, b) => sum + b.actions.length, 0);
  if (totalActions > 0 || blocks.length < 50) {
    console.log(`[fetch] got ${blocks.length} blocks, ${totalActions} total actions`);
  }
  return blocks;
}

function parseBlockStream(buf) {
  const blocks = [];
  let pos = 0;

  while (pos < buf.length) {
    if (pos + 5 > buf.length) break;
    if (buf[pos] === 0x80) break; // trailer

    const len = (buf[pos+1] << 24) | (buf[pos+2] << 16) | (buf[pos+3] << 8) | buf[pos+4];
    pos += 5;
    if (pos + len > buf.length) break;

    blocks.push(parseBlock(buf.slice(pos, pos + len)));
    pos += len;
  }

  return blocks;
}

function parseBlock(buf) {
  const block = { height: 0, hash: new Uint8Array(0), actions: [] };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 0) {
      let v = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        v |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      if (field === 1) block.height = v;
    } else if (wire === 2) {
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 2) block.hash = data;
      else if (field === 3) block.actions.push(parseAction(data));
      pos += len;
    } else break;
  }

  return block;
}

function parseAction(buf) {
  const a = { cmx: new Uint8Array(0), ephemeralKey: new Uint8Array(0), ciphertext: new Uint8Array(0), nullifier: new Uint8Array(0) };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 2) {
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 1) a.cmx = data;
      else if (field === 2) a.ephemeralKey = data;
      else if (field === 3) a.ciphertext = data;
      else if (field === 4) a.nullifier = data;
      pos += len;
    } else break;
  }

  return a;
}

function buildBinaryActions(actions) {
  const size = 32 + 32 + 32 + 52;
  const buf = new Uint8Array(4 + actions.length * size);
  const view = new DataView(buf.buffer);
  view.setUint32(0, actions.length, true);

  let off = 4;
  let valid = 0;
  for (const a of actions) {
    const hasNull = a.nullifier.length === 32;
    const hasCmx = a.cmx.length === 32;
    const hasEpk = a.ephemeralKey.length === 32;
    const hasCt = a.ciphertext.length >= 52;
    if (hasNull && hasCmx && hasEpk && hasCt) valid++;

    if (hasNull) buf.set(a.nullifier, off);
    off += 32;
    if (hasCmx) buf.set(a.cmx, off);
    off += 32;
    if (hasEpk) buf.set(a.ephemeralKey, off);
    off += 32;
    if (hasCt) buf.set(a.ciphertext.slice(0, 52), off);
    off += 52;
  }

  if (valid !== actions.length) {
    console.warn(`[build] only ${valid}/${actions.length} actions are complete`);
  }

  return buf;
}

function parseSyncStatus(buf) {
  const r = { currentHeight: 0, currentEpoch: 0, blocksInEpoch: 0, completeEpochs: 0, gigaproofStatus: 0, lastGigaproofHeight: 0 };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    if ((tag & 0x7) !== 0) break;

    let v = 0, s = 0;
    while (pos < buf.length) {
      const b = buf[pos++];
      v |= (b & 0x7f) << s;
      if (!(b & 0x80)) break;
      s += 7;
    }

    if (field === 1) r.currentHeight = v;
    else if (field === 2) r.currentEpoch = v;
    else if (field === 3) r.blocksInEpoch = v;
    else if (field === 4) r.completeEpochs = v;
    else if (field === 5) r.gigaproofStatus = v;
    else if (field === 7) r.lastGigaproofHeight = v;
  }

  return r;
}

// varint and bytesToHex imported from utils.js

// Fetch latest FROST checkpoint
async function fetchCheckpoint() {
  const path = `${serverUrl()}/zidecar.v1.Zidecar/GetCheckpoint`;
  console.log(`[checkpoint] fetching latest checkpoint`);

  // EpochRequest with epoch_index=0 (latest)
  const msg = new Uint8Array([0x08, 0x00]); // field 1, varint 0
  const body = new Uint8Array(5 + msg.length);
  body[0] = 0;
  body[1] = 0; body[2] = 0; body[3] = 0; body[4] = msg.length;
  body.set(msg, 5);

  try {
    const resp = await fetch(path, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/grpc-web+proto',
        'Accept': 'application/grpc-web+proto',
        'x-grpc-web': '1',
      },
      body,
    });

    if (!resp.ok) {
      console.warn(`[checkpoint] HTTP ${resp.status}`);
      return null;
    }

    const buf = new Uint8Array(await resp.arrayBuffer());
    if (buf.length < 5) return null;

    const len = (buf[1] << 24) | (buf[2] << 16) | (buf[3] << 8) | buf[4];
    const msgData = buf.slice(5, 5 + len);

    // Parse FrostCheckpoint - just extract epoch_index (field 1)
    const checkpoint = parseCheckpoint(msgData);
    console.log(`[checkpoint] got checkpoint epoch ${checkpoint.epoch}, height ${checkpoint.height}`);
    return checkpoint;

  } catch (e) {
    console.warn('[checkpoint] fetch failed:', e);
    return null;
  }
}

// Parse FrostCheckpoint protobuf (minimal)
function parseCheckpoint(buf) {
  const cp = { epoch: 0, height: 0, block_hash: null, tree_root: null };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 0) { // varint
      let v = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        v |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      if (field === 1) cp.epoch = v;
      else if (field === 2) cp.height = v;
    } else if (wire === 2) { // length-delimited
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 3) cp.block_hash = data;
      else if (field === 4) cp.tree_root = data;
      pos += len;
    } else {
      break;
    }
  }

  return cp;
}

// Fetch header proof for block range
async function fetchHeaderProof(fromHeight, toHeight) {
  const path = `${serverUrl()}/zidecar.v1.Zidecar/GetHeaderProof`;
  console.log(`[proof] requesting header proof ${fromHeight}-${toHeight} from ${path}`);

  // Encode ProofRequest: field 1 = from_height, field 2 = to_height
  const parts = [];
  if (fromHeight > 0) { parts.push(0x08); parts.push(...varint(fromHeight)); }
  if (toHeight > 0) { parts.push(0x10); parts.push(...varint(toHeight)); }
  const msg = new Uint8Array(parts);

  const body = new Uint8Array(5 + msg.length);
  body[0] = 0;
  body[1] = (msg.length >> 24) & 0xff;
  body[2] = (msg.length >> 16) & 0xff;
  body[3] = (msg.length >> 8) & 0xff;
  body[4] = msg.length & 0xff;
  body.set(msg, 5);

  try {
    const resp = await fetch(path, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/grpc-web+proto',
        'Accept': 'application/grpc-web+proto',
        'x-grpc-web': '1',
      },
      body,
    });

    if (!resp.ok) {
      console.warn(`[proof] HTTP ${resp.status}`);
      return null;
    }

    const buf = new Uint8Array(await resp.arrayBuffer());
    console.log(`[proof] received ${buf.length} bytes`);
    if (buf.length < 5) {
      console.warn('[proof] response too short');
      return null;
    }

    // Parse grpc-web frame
    const len = (buf[1] << 24) | (buf[2] << 16) | (buf[3] << 8) | buf[4];
    const msgData = buf.slice(5, 5 + len);

    // Parse HeaderProof - extract ligerito_proof (field 1, wire type 2)
    const proof = parseHeaderProof(msgData);
    const nfRootHex = proof.nullifier_root ? bytesToHex(proof.nullifier_root).slice(0, 16) + '...' : 'none';
    console.log(`[proof] got proof: ${proof.ligerito_proof?.length || 0} bytes, range ${proof.from_height}-${proof.to_height}, nf_root: ${nfRootHex}`);
    return proof;

  } catch (e) {
    console.warn('[proof] fetch failed:', e);
    return null;
  }
}

// Parse HeaderProof protobuf (updated with public outputs and nullifier root)
function parseHeaderProof(buf) {
  const proof = {
    ligerito_proof: null,
    from_height: 0,
    to_height: 0,
    tip_hash: null,
    gigaproof_outputs: null,
    tip_proof_outputs: null,
    continuity_verified: false,
    nullifier_root: null  // field 9 - NOMT nullifier set root
  };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 0) { // varint
      let v = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        v |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      if (field === 2) proof.from_height = v;
      else if (field === 3) proof.to_height = v;
      else if (field === 8) proof.continuity_verified = (v !== 0);
    } else if (wire === 2) { // length-delimited
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 1) proof.ligerito_proof = data;
      else if (field === 4) proof.tip_hash = data;
      else if (field === 6) proof.gigaproof_outputs = parsePublicOutputs(data);
      else if (field === 7) proof.tip_proof_outputs = parsePublicOutputs(data);
      else if (field === 9) proof.nullifier_root = data;  // NOMT root
      pos += len;
    } else {
      break; // unknown wire type
    }
  }

  return proof;
}

// Parse ProofPublicOutputs protobuf
function parsePublicOutputs(buf) {
  const outputs = {
    start_height: 0,
    end_height: 0,
    start_hash: null,
    start_prev_hash: null,
    tip_hash: null,
    tip_prev_hash: null,
    cumulative_difficulty: 0n,
    final_commitment: null,
    final_state_commitment: null,
    num_headers: 0
  };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 0) { // varint
      let v = 0n, s = 0n;
      while (pos < buf.length) {
        const b = BigInt(buf[pos++]);
        v |= (b & 0x7fn) << s;
        if (!(b & 0x80n)) break;
        s += 7n;
      }
      if (field === 1) outputs.start_height = Number(v);
      else if (field === 2) outputs.end_height = Number(v);
      else if (field === 7) outputs.cumulative_difficulty = v;
      else if (field === 10) outputs.num_headers = Number(v);
    } else if (wire === 2) { // length-delimited
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 3) outputs.start_hash = data;
      else if (field === 4) outputs.start_prev_hash = data;
      else if (field === 5) outputs.tip_hash = data;
      else if (field === 6) outputs.tip_prev_hash = data;
      else if (field === 8) outputs.final_commitment = data;
      else if (field === 9) outputs.final_state_commitment = data;
      pos += len;
    } else {
      break;
    }
  }

  return outputs;
}

// Parse a single proof: [public_outputs_len: u32][public_outputs...][log_size: u8][ligerito_proof...]
function parseSingleProof(bytes) {
  const publicLen = bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
  const proofStart = 4 + publicLen;

  if (bytes.length < proofStart + 1) {
    console.warn('[parse] proof truncated, publicLen:', publicLen, 'total:', bytes.length);
    return null;
  }

  const logSize = bytes[proofStart];
  const proofBytes = bytes.slice(proofStart + 1);

  return { publicLen, logSize, proofBytes };
}

// Verify header proof using ligerito - verifies BOTH gigaproof and tip proof
async function verifyHeaderProof(proof) {
  if (!proof || !proof.ligerito_proof || proof.ligerito_proof.length < 10) {
    console.warn('[verify] no proof to verify');
    return false;
  }

  try {
    // Combined format: [gigaproof_size: u32][gigaproof_bytes][tip_bytes]
    const bytes = proof.ligerito_proof;

    // Parse combined proof format
    const gigaproofSize = bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
    const gigaproofBytes = bytes.slice(4, 4 + gigaproofSize);
    const tipBytes = bytes.slice(4 + gigaproofSize);

    console.log(`[verify] combined: gigaproofSize=${gigaproofSize}, tipSize=${tipBytes.length}, total=${bytes.length}`);

    // Parse gigaproof
    const giga = parseSingleProof(gigaproofBytes);
    if (!giga) {
      console.warn('[verify] failed to parse gigaproof');
      return false;
    }

    // Parse tip proof (if present)
    let tip = null;
    if (tipBytes.length > 10) {
      tip = parseSingleProof(tipBytes);
      if (tip) {
        console.log(`[verify] tip proof: publicLen=${tip.publicLen}, logSize=${tip.logSize}, proofBytes=${tip.proofBytes.length}`);
      }
    }

    console.log(`[verify] gigaproof: publicLen=${giga.publicLen}, logSize=${giga.logSize}, proofBytes=${giga.proofBytes.length}`);

    // Supported config sizes in ligerito WASM
    const SUPPORTED_SIZES = new Set([12, 16, 20, 24, 26, 28, 30]);

    // Helper to verify a single proof
    async function verifySingle(parsed, name) {
      const { logSize, proofBytes } = parsed;
      const sizeDesc = `2^${logSize}`;

      // Check if this size is supported
      if (!SUPPORTED_SIZES.has(logSize)) {
        console.warn(`[verify] ${name} ${sizeDesc}: SKIPPED (size ${logSize} not supported by WASM verifier)`);
        setLigeritoDetail(`${name} 2^${logSize} (no verifier)`);
        return { ok: true, ms: '0', name, logSize, skipped: true };
      }

      setSyncStatus(`verifying ${name} ${sizeDesc}...`);
      setLigeritoDetail(`${name}...`);
      await new Promise(r => setTimeout(r, 20)); // Let UI update

      const start = performance.now();
      const ok = verifyProof(proofBytes, logSize, "sha256");
      const ms = (performance.now() - start).toFixed(0);

      console.log(`[verify] ${name} ${sizeDesc}: ${ok ? 'OK' : 'FAIL'} (${ms}ms)`);
      return { ok, ms, name, logSize, skipped: false };
    }

    // Verify BOTH proofs
    const results = [];

    // 1. Verify gigaproof (covers genesis → epoch boundary)
    const gigaResult = await verifySingle(giga, 'gigaproof');
    results.push(gigaResult);

    if (!gigaResult.ok) {
      setLigeritoDetail('gigaproof FAILED');
      return false;
    }

    // 2. Verify tip proof if present (covers epoch boundary → tip)
    if (tip) {
      const tipResult = await verifySingle(tip, 'tip');
      results.push(tipResult);

      if (!tipResult.ok) {
        setLigeritoDetail('tip FAILED');
        return false;
      }
    }

    // Summary
    const verified = results.filter(r => !r.skipped);
    const skipped = results.filter(r => r.skipped);
    const totalMs = verified.reduce((sum, r) => sum + parseInt(r.ms), 0);

    if (verified.length > 0) {
      const names = verified.map(r => `${r.name} 2^${r.logSize}`).join(', ');
      console.log(`[verify] VERIFIED: ${names} in ${totalMs}ms`);
    }
    if (skipped.length > 0) {
      const names = skipped.map(r => `${r.name} 2^${r.logSize}`).join(', ');
      console.log(`[verify] SKIPPED (no WASM verifier): ${names}`);
    }

    // Return true if at least one proof was verified (or all were skipped but valid)
    return true;

  } catch (e) {
    console.warn('[verify] verification failed:', e);
    return false;
  }
}

init();
</script>
</body>
</html>
