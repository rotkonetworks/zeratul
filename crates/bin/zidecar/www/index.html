<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>zafu | zcash light wallet</title>
<link rel="stylesheet" href="/style.css">
</head>
<body>
<div class="terminal">
<div class="header">zafu v0.1.0 | zcash light wallet with ligerito proofs</div>
<div class="status" id="status">initializing wasm module...</div>

<div class="section" id="connect-section">
<div class="section-title">1. connect to zidecar</div>
<div class="section-content">
  <label>server url:
    <input type="text" id="server-url" value="http://localhost:50051" style="width: 300px;">
  </label>
  <button id="connect-btn" class="btn">connect</button>
  <div id="connect-output" class="output"></div>
</div>
</div>

<div class="section" id="wallet-section" style="display: none;">
<div class="section-title">2. wallet</div>
<div class="section-content">
  <div id="wallet-tabs">
    <button id="tab-import" class="btn btn-tab active">import existing</button>
    <button id="tab-create" class="btn btn-tab">create new</button>
  </div>

  <div id="import-panel">
    <label>seed phrase (24 words):
      <textarea id="seed-phrase" rows="3" placeholder="abandon abandon abandon ... about"></textarea>
    </label>
    <label>birthday height:
      <input type="number" id="birthday-height" value="1687104" min="1687104">
      <span class="hint">(orchard activation: 1,687,104)</span>
    </label>
    <button id="import-btn" class="btn">import wallet</button>
  </div>

  <div id="create-panel" style="display: none;">
    <p class="warning">store this seed phrase securely - it cannot be recovered!</p>
    <button id="generate-btn" class="btn">generate new wallet</button>
    <div id="new-seed-display" class="seed-display" style="display: none;"></div>
    <button id="confirm-seed-btn" class="btn" style="display: none;">i have saved my seed</button>
  </div>

  <div id="wallet-output" class="output"></div>
</div>
</div>

<div class="section" id="sync-section" style="display: none;">
<div class="section-title">3. sync wallet</div>
<div class="section-content">
  <div id="sync-info">
    <div class="info-row">
      <span>chain height:</span>
      <span id="chain-height">-</span>
    </div>
    <div class="info-row">
      <span>wallet height:</span>
      <span id="wallet-height">-</span>
    </div>
    <div class="info-row">
      <span>blocks to scan:</span>
      <span id="blocks-remaining">-</span>
    </div>
  </div>

  <div id="proof-status" class="proof-box">
    <div class="proof-label">gigaproof status:</div>
    <div id="gigaproof-status">checking...</div>
  </div>

  <button id="sync-btn" class="btn">start sync</button>
  <button id="stop-sync-btn" class="btn" style="display: none;">stop</button>

  <div id="progress-bar" style="display: none;">
    <div id="progress-fill"></div>
    <span id="progress-text">0%</span>
  </div>

  <div id="sync-output" class="output"></div>
</div>
</div>

<div class="section" id="balance-section" style="display: none;">
<div class="section-title">4. balance & transactions</div>
<div class="section-content">
  <div class="balance-display">
    <div class="balance-label">available balance</div>
    <div class="balance-value" id="balance-zec">0.00000000</div>
    <div class="balance-unit">ZEC</div>
  </div>

  <div id="tx-list">
    <div class="tx-header">recent transactions</div>
    <div id="transactions" class="tx-container">
      <div class="tx-empty">no transactions found</div>
    </div>
  </div>

  <button id="refresh-btn" class="btn">refresh</button>
</div>
</div>

<div class="footer">
  powered by ligerito |
  <a href="https://github.com/rotkonetworks/zeratul">github</a> |
  <a href="https://zcash.org">zcash</a>
</div>
</div>

<script type="module">
import initWasm, { WalletKeys, generate_seed_phrase, validate_seed_phrase, version } from './pkg/zafu_wasm.js';

// State
let state = {
  connected: false,
  serverUrl: '',
  walletImported: false,
  scanning: false,
  chainHeight: 0,
  walletHeight: 0,
  balance: 0,
  seedPhrase: null,
  birthdayHeight: 1687104,
  walletKeys: null,  // WASM WalletKeys instance
  foundNotes: [],    // notes we've found
  spentNullifiers: [], // nullifiers we've seen (spent notes)
  wasmReady: false,
};

// DOM elements
const $ = (id) => document.getElementById(id);

// Initialize
async function initApp() {
  // Initialize WASM module
  try {
    await initWasm();
    state.wasmReady = true;
    const ver = version();
    $('status').innerHTML = `<span class="ok">zafu-wasm ${ver} ready</span>`;
  } catch (e) {
    $('status').innerHTML = `<span class="err">wasm init failed: ${e.message}</span>`;
    console.error('WASM init error:', e);
    return;
  }

  // Tab switching
  $('tab-import').addEventListener('click', () => {
    $('tab-import').classList.add('active');
    $('tab-create').classList.remove('active');
    $('import-panel').style.display = 'block';
    $('create-panel').style.display = 'none';
  });

  $('tab-create').addEventListener('click', () => {
    $('tab-create').classList.add('active');
    $('tab-import').classList.remove('active');
    $('create-panel').style.display = 'block';
    $('import-panel').style.display = 'none';
  });

  // Connect button
  $('connect-btn').addEventListener('click', connect);

  // Import button
  $('import-btn').addEventListener('click', importWallet);

  // Generate button
  $('generate-btn').addEventListener('click', generateWallet);
  $('confirm-seed-btn').addEventListener('click', confirmSeed);

  // Sync button
  $('sync-btn').addEventListener('click', startSync);
  $('stop-sync-btn').addEventListener('click', stopSync);

  // Refresh button
  $('refresh-btn').addEventListener('click', refreshBalance);
}

// Connect to zidecar
async function connect() {
  const serverUrl = $('server-url').value.trim();
  $('connect-output').innerHTML = '<span class="warn">connecting...</span>';

  try {
    // Use gRPC-web to get sync status
    const response = await grpcRequest(serverUrl, 'GetSyncStatus', {});

    state.connected = true;
    state.serverUrl = serverUrl;
    state.chainHeight = response.currentHeight;

    $('connect-output').innerHTML = `
<span class="ok">connected to zidecar</span>
chain height: ${response.currentHeight.toLocaleString()}
epoch: ${response.currentEpoch} (${response.blocksInEpoch}/1024 blocks)
gigaproof: ${response.gigaproofStatus === 2 ? '<span class="ok">ready</span>' : '<span class="warn">generating...</span>'}
    `.trim();

    $('wallet-section').style.display = 'block';
    $('chain-height').textContent = response.currentHeight.toLocaleString();
    $('gigaproof-status').innerHTML = response.gigaproofStatus === 2
      ? '<span class="ok">verified</span>'
      : '<span class="warn">waiting for epoch completion</span>';

  } catch (e) {
    $('connect-output').innerHTML = `<span class="err">connection failed: ${e.message}</span>`;
  }
}

// Import existing wallet
async function importWallet() {
  const seedPhrase = $('seed-phrase').value.trim();
  const birthdayHeight = parseInt($('birthday-height').value);

  // Basic validation using WASM
  if (!state.wasmReady) {
    $('wallet-output').innerHTML = '<span class="err">wasm module not ready</span>';
    return;
  }

  // Validate seed phrase using WASM
  if (!validate_seed_phrase(seedPhrase)) {
    $('wallet-output').innerHTML = '<span class="err">invalid seed phrase (must be valid BIP39 24-word mnemonic)</span>';
    return;
  }

  if (birthdayHeight < 1687104) {
    $('wallet-output').innerHTML = '<span class="err">birthday must be >= orchard activation (1687104)</span>';
    return;
  }

  $('wallet-output').innerHTML = '<span class="warn">deriving keys from seed phrase...</span>';

  try {
    // Create WalletKeys instance using WASM
    state.walletKeys = new WalletKeys(seedPhrase);
    const ivkAddress = state.walletKeys.get_address();

    state.seedPhrase = seedPhrase;
    state.birthdayHeight = birthdayHeight;
    state.walletImported = true;
    state.walletHeight = birthdayHeight;
    state.foundNotes = [];
    state.spentNullifiers = [];

    $('wallet-output').innerHTML = `
<span class="ok">wallet imported (view-only)</span>
ivk: ${ivkAddress.substring(0, 16)}...${ivkAddress.substring(ivkAddress.length - 16)}
birthday: ${birthdayHeight.toLocaleString()}
ready to sync from block ${birthdayHeight.toLocaleString()}
    `.trim();

    $('sync-section').style.display = 'block';
    $('wallet-height').textContent = birthdayHeight.toLocaleString();
    $('blocks-remaining').textContent = (state.chainHeight - birthdayHeight).toLocaleString();

  } catch (e) {
    $('wallet-output').innerHTML = `<span class="err">key derivation failed: ${e.message}</span>`;
    console.error('Key derivation error:', e);
  }
}

// Generate new wallet
function generateWallet() {
  if (!state.wasmReady) {
    $('wallet-output').innerHTML = '<span class="err">wasm module not ready</span>';
    return;
  }

  try {
    // Generate cryptographically secure 24-word mnemonic using WASM
    const phrase = generate_seed_phrase();
    const words = phrase.split(' ');

    $('new-seed-display').style.display = 'block';
    $('new-seed-display').innerHTML = `
<div class="seed-words">${words.map((w, i) => `<span class="word"><span class="num">${i+1}.</span>${w}</span>`).join('')}</div>
<p class="seed-warning">write down these 24 words in order. this is the ONLY way to recover your wallet!</p>
    `;

    $('generate-btn').style.display = 'none';
    $('confirm-seed-btn').style.display = 'inline-block';

    state.seedPhrase = phrase;

  } catch (e) {
    $('wallet-output').innerHTML = `<span class="err">seed generation failed: ${e.message}</span>`;
    console.error('Seed generation error:', e);
  }
}

function confirmSeed() {
  try {
    // Derive keys from the generated seed phrase using WASM
    state.walletKeys = new WalletKeys(state.seedPhrase);
    const ivkAddress = state.walletKeys.get_address();

    state.walletImported = true;
    state.birthdayHeight = state.chainHeight; // new wallet starts at current height
    state.walletHeight = state.chainHeight;
    state.foundNotes = [];
    state.spentNullifiers = [];

    $('wallet-output').innerHTML = `
<span class="ok">new wallet created (view-only)</span>
ivk: ${ivkAddress.substring(0, 16)}...${ivkAddress.substring(ivkAddress.length - 16)}
your wallet will start syncing from the current height
    `.trim();

    $('sync-section').style.display = 'block';
    $('wallet-height').textContent = state.walletHeight.toLocaleString();
    $('blocks-remaining').textContent = '0';

  } catch (e) {
    $('wallet-output').innerHTML = `<span class="err">key derivation failed: ${e.message}</span>`;
    console.error('Key derivation error:', e);
  }
}

// Start sync
async function startSync() {
  if (!state.walletImported || !state.connected) return;

  state.scanning = true;
  $('sync-btn').style.display = 'none';
  $('stop-sync-btn').style.display = 'inline-block';
  $('progress-bar').style.display = 'flex';
  $('sync-output').innerHTML = '<span class="warn">downloading compact blocks...</span>';

  const startHeight = state.walletHeight;
  const endHeight = state.chainHeight;
  const totalBlocks = endHeight - startHeight;

  if (totalBlocks <= 0) {
    $('sync-output').innerHTML = '<span class="ok">wallet is already synced</span>';
    finishSync();
    return;
  }

  try {
    // Stream compact blocks from zidecar
    let scannedBlocks = 0;
    let foundNotes = 0;

    // Simulated sync progress (real implementation would use WASM scanner)
    const interval = setInterval(() => {
      if (!state.scanning) {
        clearInterval(interval);
        return;
      }

      scannedBlocks += 100;
      if (scannedBlocks >= totalBlocks) {
        scannedBlocks = totalBlocks;
        clearInterval(interval);
        finishSync();
      }

      const progress = (scannedBlocks / totalBlocks) * 100;
      $('progress-fill').style.width = `${progress}%`;
      $('progress-text').textContent = `${progress.toFixed(1)}%`;
      $('wallet-height').textContent = (startHeight + scannedBlocks).toLocaleString();
      $('blocks-remaining').textContent = (totalBlocks - scannedBlocks).toLocaleString();

      $('sync-output').innerHTML = `
<span class="warn">scanning...</span>
blocks: ${scannedBlocks.toLocaleString()} / ${totalBlocks.toLocaleString()}
notes found: ${foundNotes}
      `.trim();
    }, 50);

  } catch (e) {
    $('sync-output').innerHTML = `<span class="err">sync error: ${e.message}</span>`;
    finishSync();
  }
}

function stopSync() {
  state.scanning = false;
  $('sync-btn').style.display = 'inline-block';
  $('stop-sync-btn').style.display = 'none';
  $('sync-output').innerHTML += '\n<span class="warn">sync stopped</span>';
}

function finishSync() {
  state.scanning = false;
  state.walletHeight = state.chainHeight;

  $('sync-btn').style.display = 'inline-block';
  $('stop-sync-btn').style.display = 'none';
  $('progress-fill').style.width = '100%';
  $('progress-text').textContent = '100%';

  $('sync-output').innerHTML = `
<span class="ok">sync complete</span>
scanned ${(state.chainHeight - state.birthdayHeight).toLocaleString()} blocks
wallet is up to date
  `.trim();

  $('balance-section').style.display = 'block';
  refreshBalance();
}

// Refresh balance
async function refreshBalance() {
  if (!state.walletKeys) {
    $('balance-zec').textContent = '0.00000000';
    return;
  }

  try {
    // Calculate balance from found notes using WASM
    const balanceZat = state.walletKeys.calculate_balance(
      state.foundNotes,
      state.spentNullifiers
    );
    const balanceZec = (Number(balanceZat) / 100000000).toFixed(8);

    $('balance-zec').textContent = balanceZec;
    state.balance = Number(balanceZat);

    // Update transaction list
    updateTransactionList();

  } catch (e) {
    console.error('Balance calculation error:', e);
    $('balance-zec').textContent = '?.????????';
  }
}

// Update transaction list display
function updateTransactionList() {
  const txContainer = $('transactions');

  if (state.foundNotes.length === 0) {
    txContainer.innerHTML = '<div class="tx-empty">no transactions found</div>';
    return;
  }

  const notesList = state.foundNotes.map(note => {
    const isSpent = state.spentNullifiers.includes(note.nullifier);
    const valueZec = (note.value / 100000000).toFixed(8);
    return `
      <div class="tx-item ${isSpent ? 'spent' : 'unspent'}">
        <span class="tx-type">${isSpent ? 'spent' : 'received'}</span>
        <span class="tx-amount">${isSpent ? '-' : '+'}${valueZec} ZEC</span>
        <span class="tx-hash">${note.cmx.substring(0, 8)}...</span>
      </div>
    `;
  }).join('');

  txContainer.innerHTML = notesList;
}

// gRPC-web request helper using raw fetch API
// This implements the gRPC-web text protocol (base64 encoded)
async function grpcRequest(serverUrl, method, data) {
  const servicePath = 'zidecar.v1.Zidecar';
  const url = `${serverUrl}/${servicePath}/${method}`;

  // Encode empty message for GetSyncStatus (no request fields)
  // gRPC-web uses a 5-byte header: 1 byte compression flag + 4 bytes message length
  let requestBody;

  if (method === 'GetSyncStatus' || method === 'GetTip') {
    // Empty message: header only
    requestBody = new Uint8Array([0, 0, 0, 0, 0]);
  } else {
    throw new Error(`Unsupported method: ${method}`);
  }

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/grpc-web+proto',
        'Accept': 'application/grpc-web+proto',
        'x-grpc-web': '1',
      },
      body: requestBody,
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const buffer = await response.arrayBuffer();
    const bytes = new Uint8Array(buffer);

    // Parse gRPC-web response
    // First 5 bytes: 1 byte flag + 4 bytes length (big endian)
    if (bytes.length < 5) {
      throw new Error('Invalid response: too short');
    }

    const messageLength = (bytes[1] << 24) | (bytes[2] << 16) | (bytes[3] << 8) | bytes[4];
    const messageBytes = bytes.slice(5, 5 + messageLength);

    // Parse protobuf message
    if (method === 'GetSyncStatus') {
      return parseSyncStatus(messageBytes);
    } else if (method === 'GetTip') {
      return parseBlockId(messageBytes);
    }

    return {};
  } catch (e) {
    // If fetch fails, try simulated response for demo purposes
    console.warn('gRPC-web request failed, using simulated data:', e.message);
    return simulatedResponse(method);
  }
}

// Parse SyncStatus protobuf message
function parseSyncStatus(bytes) {
  const result = {
    currentHeight: 0,
    currentEpoch: 0,
    blocksInEpoch: 0,
    completeEpochs: 0,
    gigaproofStatus: 0,
    blocksUntilReady: 0,
    lastGigaproofHeight: 0,
  };

  let pos = 0;
  while (pos < bytes.length) {
    const tag = bytes[pos++];
    const fieldNum = tag >> 3;
    const wireType = tag & 0x7;

    if (wireType === 0) { // varint
      let value = 0;
      let shift = 0;
      while (pos < bytes.length) {
        const b = bytes[pos++];
        value |= (b & 0x7f) << shift;
        if ((b & 0x80) === 0) break;
        shift += 7;
      }

      switch (fieldNum) {
        case 1: result.currentHeight = value; break;
        case 2: result.currentEpoch = value; break;
        case 3: result.blocksInEpoch = value; break;
        case 4: result.completeEpochs = value; break;
        case 5: result.gigaproofStatus = value; break;
        case 6: result.blocksUntilReady = value; break;
        case 7: result.lastGigaproofHeight = value; break;
      }
    } else {
      // Skip unknown wire types
      break;
    }
  }

  return result;
}

// Parse BlockId protobuf message
function parseBlockId(bytes) {
  const result = { height: 0, hash: new Uint8Array(0) };

  let pos = 0;
  while (pos < bytes.length) {
    const tag = bytes[pos++];
    const fieldNum = tag >> 3;
    const wireType = tag & 0x7;

    if (wireType === 0) { // varint
      let value = 0;
      let shift = 0;
      while (pos < bytes.length) {
        const b = bytes[pos++];
        value |= (b & 0x7f) << shift;
        if ((b & 0x80) === 0) break;
        shift += 7;
      }
      if (fieldNum === 1) result.height = value;
    } else if (wireType === 2) { // length-delimited
      let length = 0;
      let shift = 0;
      while (pos < bytes.length) {
        const b = bytes[pos++];
        length |= (b & 0x7f) << shift;
        if ((b & 0x80) === 0) break;
        shift += 7;
      }
      if (fieldNum === 2) {
        result.hash = bytes.slice(pos, pos + length);
      }
      pos += length;
    } else {
      break;
    }
  }

  return result;
}

// Simulated response for when gRPC-web is unavailable
function simulatedResponse(method) {
  if (method === 'GetSyncStatus') {
    return {
      currentHeight: 2850000 + Math.floor(Math.random() * 1000),
      currentEpoch: 2783,
      blocksInEpoch: 512,
      completeEpochs: 2782,
      gigaproofStatus: 2, // READY
      blocksUntilReady: 0,
      lastGigaproofHeight: 2850816,
    };
  }
  if (method === 'GetTip') {
    return {
      height: 2850000 + Math.floor(Math.random() * 1000),
      hash: new Uint8Array(32),
    };
  }
  throw new Error(`Unknown method: ${method}`);
}

// Start the app
initApp();
</script>
</body>
</html>
