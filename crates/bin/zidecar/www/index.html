<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>zafu | zcash wallet</title>
<meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
<meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --bg: #0d0d12;
  --surface: #16161d;
  --border: #2a2a35;
  --gold: #f4a31e;
  --text: #e0e0e4;
  --dim: #707078;
  --ok: #50c878;
  --err: #c05050;
}
body {
  background: var(--bg);
  color: var(--text);
  font-family: 'SF Mono', 'Consolas', monospace;
  font-size: 13px;
  line-height: 1.6;
  padding: 24px;
  min-height: 100vh;
}
.container {
  max-width: 700px;
  margin: 0 auto;
}
h1 {
  color: var(--gold);
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 24px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border);
}
.section {
  margin-bottom: 24px;
  padding: 16px;
  background: var(--surface);
  border: 1px solid var(--border);
}
.section-title {
  color: var(--dim);
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 12px;
}
.row {
  display: flex;
  gap: 12px;
  align-items: center;
  margin-bottom: 8px;
}
.row:last-child { margin-bottom: 0; }
input, textarea, select {
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  padding: 8px 12px;
  font-family: inherit;
  font-size: 12px;
  flex: 1;
}
input:focus, textarea:focus {
  outline: none;
  border-color: var(--gold);
}
textarea { min-height: 60px; resize: vertical; }
button {
  background: var(--gold);
  color: #000;
  border: none;
  padding: 8px 16px;
  font-family: inherit;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  cursor: pointer;
}
button:hover { filter: brightness(1.1); }
button:disabled { background: var(--border); color: var(--dim); cursor: not-allowed; }
.status {
  padding: 12px;
  background: var(--bg);
  border-left: 3px solid var(--border);
  font-size: 12px;
  white-space: pre-wrap;
  word-wrap: break-word;
  min-height: 40px;
}
.status.ok { border-color: var(--ok); }
.status.err { border-color: var(--err); }
.status.active { border-color: var(--gold); }
.progress-bar {
  height: 8px;
  background: var(--bg);
  margin: 12px 0;
  overflow: hidden;
  position: relative;
}
.progress-fill {
  height: 100%;
  background: var(--gold);
  width: 0%;
  transition: width 0.2s;
  position: absolute;
  top: 0;
  left: 0;
}
.progress-verified {
  height: 100%;
  background: var(--ok);
  width: 0%;
  transition: width 0.2s;
  position: absolute;
  top: 0;
  left: 0;
}
.progress-legend {
  display: flex;
  gap: 16px;
  font-size: 10px;
  margin-top: 4px;
}
.progress-legend span::before {
  content: '';
  display: inline-block;
  width: 8px;
  height: 8px;
  margin-right: 4px;
  vertical-align: middle;
}
.legend-synced::before { background: var(--gold); }
.legend-verified::before { background: var(--ok); }
.balance {
  font-size: 28px;
  font-weight: 600;
  color: var(--gold);
  text-align: center;
  padding: 20px;
}
.balance span { font-size: 14px; color: var(--dim); }
.info-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  font-size: 12px;
}
.info-grid .label { color: var(--dim); }
.info-grid .value { text-align: right; }
.hidden { display: none; }
.note-list {
  max-height: 150px;
  overflow-y: auto;
  font-size: 11px;
}
.note {
  padding: 6px 0;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
}
.note:last-child { border-bottom: none; }
.note.spent { opacity: 0.5; }
.note .amount { color: var(--ok); }
.note.spent .amount { color: var(--err); }
.security-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}
.security-layer {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  background: var(--bg);
  border-left: 2px solid var(--border);
}
.security-layer.active { border-color: var(--gold); }
.security-layer.verified { border-color: var(--ok); }
.security-layer.unavailable { opacity: 0.5; }
.sec-icon {
  font-size: 16px;
  width: 20px;
  text-align: center;
  color: var(--dim);
}
.security-layer.active .sec-icon,
.security-layer.verified .sec-icon { color: var(--gold); }
.sec-info { flex: 1; min-width: 0; }
.sec-name { font-size: 11px; font-weight: 600; }
.sec-desc { font-size: 9px; color: var(--dim); }
.sec-status {
  font-size: 9px;
  color: var(--dim);
  text-align: right;
  white-space: nowrap;
}
.security-layer.verified .sec-status { color: var(--ok); }
.proof-details {
  margin-top: 12px;
  padding: 10px;
  background: var(--bg);
  font-size: 11px;
}
.proof-title {
  color: var(--dim);
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}
.proof-grid {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 4px 12px;
}
.proof-grid .label { color: var(--dim); }
.proof-grid .value { text-align: right; font-family: monospace; }
.proof-grid .value.hash { font-size: 10px; overflow: hidden; text-overflow: ellipsis; }
.proof-grid .value.ok { color: var(--ok); }
.proof-grid .value.err { color: var(--err); }

/* Modal styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s, visibility 0.2s;
}
.modal-overlay.active {
  opacity: 1;
  visibility: visible;
}
.modal {
  background: var(--surface);
  border: 1px solid var(--border);
  max-width: 520px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  position: relative;
}
.modal-header {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px;
  border-bottom: 1px solid var(--border);
}
.modal-icon {
  font-size: 24px;
  color: var(--gold);
}
.modal-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--gold);
}
.modal-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: none;
  color: var(--dim);
  font-size: 18px;
  cursor: pointer;
  padding: 4px 8px;
}
.modal-close:hover { color: var(--text); }
.modal-body {
  padding: 16px;
}
.modal-section {
  margin-bottom: 16px;
}
.modal-section:last-child { margin-bottom: 0; }
.modal-section-title {
  color: var(--gold);
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}
.modal-text {
  font-size: 12px;
  line-height: 1.7;
  color: var(--text);
}
.modal-text p { margin-bottom: 8px; }
.modal-text p:last-child { margin-bottom: 0; }
.comparison-table {
  width: 100%;
  font-size: 11px;
  border-collapse: collapse;
  margin-top: 8px;
}
.comparison-table th,
.comparison-table td {
  padding: 8px;
  text-align: left;
  border-bottom: 1px solid var(--border);
}
.comparison-table th {
  color: var(--dim);
  font-weight: 600;
  text-transform: uppercase;
  font-size: 10px;
}
.comparison-table td:first-child { color: var(--dim); }
.comparison-table .old { color: var(--err); }
.comparison-table .new { color: var(--ok); }
.security-layer { cursor: pointer; }
.security-layer:hover { background: var(--border); }
.tech-tag {
  display: inline-block;
  background: var(--bg);
  padding: 2px 6px;
  font-size: 10px;
  margin: 2px;
  border: 1px solid var(--border);
}
</style>
</head>
<body>
<div class="container">
<h1>zafu <span style="color: var(--dim); font-weight: 400">zcash light wallet</span></h1>

<div style="background: rgba(192, 80, 80, 0.15); border: 1px solid var(--err); padding: 12px; margin-bottom: 24px; font-size: 11px;">
  <div style="color: var(--err); font-weight: 600; margin-bottom: 6px;">⚠ EXPERIMENTAL DEMO</div>
  <div style="color: var(--dim); line-height: 1.5;">
    <strong>Client-Side Rendered (CSR):</strong> All cryptographic operations run entirely in your browser.
    Your seed phrase never leaves this device—we cannot access it.<br>
    <strong>Recommendation:</strong> Use an old wallet with no value attached for testing.
    This is experimental software; do not use with funds you cannot afford to lose.
  </div>
</div>

<div class="section">
  <div class="section-title">server</div>
  <div class="row">
    <input type="text" id="server-url" value="https://zcash.rotko.net" placeholder="zidecar server">
    <button id="connect-btn">connect</button>
  </div>
  <div class="status" id="connect-status">not connected</div>
</div>

<div class="section hidden" id="wallet-section">
  <div class="section-title">wallet</div>
  <div class="row">
    <textarea id="seed-phrase" placeholder="enter 24-word seed phrase"></textarea>
  </div>
  <div class="row">
    <input type="number" id="birthday" value="1687104" min="1" placeholder="birthday height">
    <button id="import-btn">import</button>
  </div>
  <div class="status" id="wallet-status">enter seed phrase (orchard only)</div>
</div>

<div class="section hidden" id="sync-section">
  <div class="section-title">sync</div>
  <div class="info-grid" id="sync-info" style="grid-template-columns: 1fr 1fr 1fr 1fr;">
    <span class="label">chain tip</span><span class="value" id="chain-height">-</span>
    <span class="label">proven to</span><span class="value" id="proven-height" style="color: var(--ok)">-</span>
    <span class="label">scan from</span><span class="value" id="birthday-height">-</span>
    <span class="label">scanned to</span><span class="value" id="wallet-height">-</span>
  </div>
  <div class="progress-bar">
    <div class="progress-verified" id="progress-verified"></div>
    <div class="progress-fill" id="progress"></div>
  </div>
  <div class="progress-legend">
    <span class="legend-verified">proven (genesis→tip)</span>
    <span class="legend-synced">scanned (birthday→tip)</span>
  </div>
  <div class="row">
    <button id="sync-btn">sync</button>
    <button id="stop-btn" class="hidden">stop</button>
  </div>
  <div class="status" id="sync-status">ready to sync</div>
</div>

<div class="section hidden" id="security-section">
  <div class="section-title">security layers</div>
  <div class="security-grid" style="grid-template-columns: 1fr 1fr 1fr;">
    <div class="security-layer" id="sec-ligerito">
      <div class="sec-icon">◈</div>
      <div class="sec-info">
        <div class="sec-name">Ligerito</div>
        <div class="sec-desc">header chain ZKP</div>
      </div>
      <div class="sec-status" id="sec-ligerito-status">-</div>
    </div>
    <div class="security-layer" id="sec-zanchor">
      <div class="sec-icon">●</div>
      <div class="sec-info">
        <div class="sec-name">Zanchor</div>
        <div class="sec-desc">polkadot finality</div>
      </div>
      <div class="sec-status" id="sec-zanchor-status">-</div>
    </div>
    <div class="security-layer" id="sec-nomt">
      <div class="sec-icon">⌘</div>
      <div class="sec-info">
        <div class="sec-name">NOMT</div>
        <div class="sec-desc">state proof</div>
      </div>
      <div class="sec-status" id="sec-nomt-status">-</div>
    </div>
  </div>
  <div class="proof-details hidden" id="proof-details">
    <div class="proof-title">proof verification</div>
    <div class="proof-grid">
      <span class="label">proven range</span><span class="value" id="proof-giga-range">-</span>
      <span class="label">tip hash</span><span class="value hash" id="proof-tip-hash">-</span>
      <span class="label">chain work</span><span class="value" id="proof-work">-</span>
      <span class="label">continuity</span><span class="value" id="proof-continuity">-</span>
      <span class="label">NOMT root</span><span class="value hash" id="proof-nomt-root">-</span>
      <span class="label">state epoch</span><span class="value" id="proof-state-epoch">-</span>
    </div>
  </div>
</div>

<div class="section hidden" id="balance-section">
  <div class="section-title">balance</div>
  <div class="balance" id="balance">0.00000000 <span>ZEC</span></div>
  <div class="note-list" id="notes"></div>
</div>

</div>

<!-- Modal: Ligerito -->
<div class="modal-overlay" id="modal-ligerito">
  <div class="modal">
    <button class="modal-close" onclick="closeModal('ligerito')">&times;</button>
    <div class="modal-header">
      <div class="modal-icon">◈</div>
      <div class="modal-title">Ligerito - Header Chain Proof</div>
    </div>
    <div class="modal-body">
      <div class="modal-section">
        <div class="modal-section-title">Threat Model</div>
        <div class="modal-text">
          <p>A malicious server can trivially lie about which chain is canonical. Without header verification, it can present a fabricated chain with invalid PoW, convince the client to accept transactions on a minority fork, or hide reorgs entirely.</p>
          <p>Lightwalletd clients have no defense against this - they trust the server completely.</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Security Guarantee</div>
        <div class="modal-text">
          <p>The proof asserts that for blocks 1..N: each header's PoW satisfies its target, the difficulty adjustment algorithm was correctly applied at each epoch, timestamps are monotonically increasing, and hash(header[i]) = prev_hash(header[i+1]).</p>
          <p>The client verifies this in O(log²N/log log N) time without downloading headers.</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Proof Structure</div>
        <div class="modal-text">
          <p><strong>Gigaproof:</strong> Proves genesis → last epoch boundary. Generated once per ~1024 blocks. ~200KB, proves ~2.7M headers.</p>
          <p><strong>Tip proof:</strong> Proves epoch boundary → current tip. Generated on-demand. Continuity check: tip_proof.start_hash == gigaproof.end_hash.</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">FRI Folding Verification</div>
        <div class="modal-text">
          <p>Verification uses recursive FRI (Fast Reed-Solomon IOP) folding. The polynomial is committed at dimension 2^k, then folded down in rounds:</p>
          <p style="font-family: monospace; font-size: 11px; color: var(--gold); margin: 8px 0;">
            2^26 → 2^23 → 2^20 → 2^17 → 2^14 → 2^11 → final
          </p>
          <p>Each round: verifier sends random challenge α, prover commits to f'(x) = f_even(x) + α·f_odd(x). Verifier spot-checks consistency at random points. After ℓ rounds, the polynomial is small enough to send directly.</p>
          <p>Soundness error: (ρ)^|S| per round, where ρ = rate and |S| = query count (~148 queries for 100-bit security).</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Assumptions</div>
        <div class="modal-text">
          <p>Soundness relies on the hardness of Reed-Solomon proximity testing. <a href="https://ligerito.rotko.net" target="_blank" style="color: var(--gold)">Ligerito</a> is a polynomial commitment scheme with WI (not ZK) - the witness is not hidden, only correctness is proven.</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Download Proofs</div>
        <div class="modal-text">
          <div style="display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap;">
            <button id="download-gigaproof">Gigaproof (genesis→epoch)</button>
            <button id="download-tipproof">Tip Proof (epoch→tip)</button>
          </div>
          <div id="proof-info" style="margin-top: 8px; font-size: 10px; color: var(--dim);">
            Connect and sync to fetch proof data.
          </div>
          <p style="margin-top: 8px; font-size: 10px; color: var(--dim);">Proofs can be verified independently using the ligerito CLI verifier.</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal: Zanchor -->
<div class="modal-overlay" id="modal-zanchor">
  <div class="modal">
    <button class="modal-close" onclick="closeModal('zanchor')">&times;</button>
    <div class="modal-header">
      <div class="modal-icon">●</div>
      <div class="modal-title">Zanchor - Polkadot Finality</div>
    </div>
    <div class="modal-body">
      <div class="modal-section">
        <div class="modal-section-title">Threat Model</div>
        <div class="modal-text">
          <p>Zcash uses Nakamoto consensus - finality is probabilistic. A 51% attacker can reorg arbitrarily deep. Even without 51%, a malicious server can claim any block is "canonical" and the client has no way to dispute it without an independent reference.</p>
          <p>Lightwalletd provides no finality guarantees whatsoever.</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Security Guarantee</div>
        <div class="modal-text">
          <p>Zanchor checkpoints (block_hash, tree_root) are written to a Polkadot parachain. Once finalized by GRANDPA (BFT finality with 1000+ validators), the checkpoint becomes irreversible - even a Zcash 51% attack cannot reorg past it.</p>
          <p>The client can verify checkpoint authenticity via Polkadot light client or trusted RPC.</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Checkpoint Structure</div>
        <div class="modal-text">
          <p><strong>epoch:</strong> Sequential checkpoint number</p>
          <p><strong>block_hash:</strong> Zcash block hash at checkpoint height</p>
          <p><strong>tree_root:</strong> Commitment to nullifier set state</p>
          <p>Checkpoints are signed via FROST threshold signature (t-of-n scheme).</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Assumptions</div>
        <div class="modal-text">
          <p>Trust assumption shifts from "the server is honest" to "Polkadot validators are honest (BFT: >2/3 honest)". This is a strictly weaker assumption - compromising 1000+ validators is harder than compromising one server.</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Paseo Parachain Verification</div>
        <div class="modal-text">
          <p style="font-size: 11px; color: var(--dim);">ParaId 5082 on Paseo testnet. Query on-chain state to verify checkpoint authenticity.</p>
          <button id="verify-paseo" style="margin-top: 8px;">Verify on Paseo</button>
          <div id="paseo-verify-status" style="margin-top: 8px; font-size: 11px; padding: 8px; background: var(--bg); display: none;">
            <div id="paseo-verify-result"></div>
          </div>
          <p style="margin-top: 8px; font-size: 10px; color: var(--dim);">
            RPC: <a href="https://paseo.rpc.amforc.com" target="_blank" style="color: var(--gold);">paseo.rpc.amforc.com</a> |
            Explorer: <a href="https://paseo.subscan.io/parachain/5082" target="_blank" style="color: var(--gold);">subscan</a>
          </p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Download Checkpoint</div>
        <div class="modal-text">
          <button id="download-checkpoint" style="margin-top: 8px;">Download Latest Checkpoint</button>
          <p style="margin-top: 8px; font-size: 10px; color: var(--dim);">JSON: epoch, height, block_hash, tree_root</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal: NOMT -->
<div class="modal-overlay" id="modal-nomt">
  <div class="modal">
    <button class="modal-close" onclick="closeModal('nomt')">&times;</button>
    <div class="modal-header">
      <div class="modal-icon">⌘</div>
      <div class="modal-title">NOMT - Nullifier State Proof</div>
    </div>
    <div class="modal-body">
      <div class="modal-section">
        <div class="modal-section-title">Threat Model</div>
        <div class="modal-text">
          <p>The nullifier set (all spent note commitments) is critical for double-spend prevention. A malicious server can: (1) omit nullifiers to make spent notes appear unspent, (2) inject fake nullifiers to make unspent notes appear spent, or (3) serve inconsistent state to different clients.</p>
          <p>Lightwalletd clients accept nullifier queries on faith.</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Security Guarantee</div>
        <div class="modal-text">
          <p>NOMT maintains a merkle tree over the nullifier set. For any query "is nullifier X in the set?", the server provides a membership/non-membership proof verifiable against the root.</p>
          <p>The root is committed in the header chain proof, binding it to the proven chain state.</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Proof Verification</div>
        <div class="modal-text">
          <p><strong>Membership proof:</strong> Path from leaf to root, O(log N) hashes</p>
          <p><strong>Non-membership proof:</strong> Adjacent leaves proving gap at query position</p>
          <p>Client computes root from proof, compares to committed root. Forgery requires collision in Blake3.</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Assumptions</div>
        <div class="modal-text">
          <p>Soundness: collision resistance of Blake3. Completeness: server must have the full nullifier set to generate valid proofs. The "Nearly-Optimal" in NOMT refers to page-aligned storage for efficient disk I/O during proof generation.</p>
        </div>
      </div>
      <div class="modal-section">
        <div class="modal-section-title">Download State Root</div>
        <div class="modal-text">
          <button id="download-nomt-root" style="margin-top: 8px;">Download Current State</button>
          <p style="margin-top: 8px; font-size: 10px; color: var(--dim);">JSON: nullifier_root, proven_height, nullifiers_observed</p>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
import initWasm, { WalletKeys, validate_seed_phrase, version, num_threads } from './pkg/zafu_wasm.js';
import * as zafuWasm from './pkg/zafu_wasm.js';
import initLigerito, { verify as verifyProof } from './ligerito.js';
import * as ligerito from './ligerito.js';
import { signal, computed, effect, batch, bindText, bindStyle, bindVisible, varint, bytesToHex, formatNumber, formatZec } from './utils.js';

const $ = id => document.getElementById(id);

// ============== PROOF CACHE FOR DOWNLOAD ==============
let lastProofData = null;
let lastCheckpointData = null;

// ============== REACTIVE STATE ==============
const [connected, setConnected] = signal(false);
const [serverUrl, setServerUrl] = signal('');
const [chainHeight, setChainHeight] = signal(0);
const [birthday, setBirthday] = signal(0);
const [walletHeight, setWalletHeight] = signal(0);
const [scanning, setScanning] = signal(false);
const [notes, setNotes] = signal([]);
const [spent, setSpent] = signal([]);
const [gigaproofHeight, setGigaproofHeight] = signal(0);
const [verifiedHeight, setVerifiedHeight] = signal(0);
const [proofsVerified, setProofsVerified] = signal(0);
const [nullifiersObserved, setNullifiersObserved] = signal(0);
const [serverNullifierRoot, setServerNullifierRoot] = signal(null);
const [syncStatus, setSyncStatus] = signal('ready to sync');
const [syncStatusClass, setSyncStatusClass] = signal('');
const [connectStatus, setConnectStatus] = signal('not connected');
const [connectStatusClass, setConnectStatusClass] = signal('');
const [walletStatus, setWalletStatus] = signal('enter seed phrase (orchard only)');
const [walletStatusClass, setWalletStatusClass] = signal('');
const [walletKeys, setWalletKeys] = signal(null);

// Security layer signals - start with 'pending' so users know verification is expected
const [ligeritoStatus, setLigeritoStatus] = signal('active');
const [ligeritoDetail, setLigeritoDetail] = signal('pending');
const [zanchorStatus, setZanchorStatus] = signal('none');
const [zanchorDetail, setZanchorDetail] = signal('checking...');
const [nomtStatus, setNomtStatus] = signal('active');
const [nomtDetail, setNomtDetail] = signal('pending');

// Proof details signals
const [proofRange, setProofRange] = signal('-');
const [proofTipHash, setProofTipHash] = signal('-');
const [proofWork, setProofWork] = signal('-');
const [proofContinuity, setProofContinuity] = signal('-');
const [proofContinuityClass, setProofContinuityClass] = signal('value');
const [proofNomtRoot, setProofNomtRoot] = signal('-');
const [proofNomtRootClass, setProofNomtRootClass] = signal('value hash');
const [proofStateEpoch, setProofStateEpoch] = signal('-');
const [showProofDetails, setShowProofDetails] = signal(false);

// Computed values
const provenHeight = computed(() => {
  const v = verifiedHeight();
  const g = gigaproofHeight();
  return v > g ? v : g;
});

const provenHeightText = computed(() => {
  const h = provenHeight();
  return h > 0 ? h.toLocaleString() : '-';
});

const chainHeightText = computed(() => {
  const h = chainHeight();
  return h > 0 ? h.toLocaleString() : '-';
});

const walletHeightText = computed(() => {
  const h = walletHeight();
  return h > 0 ? h.toLocaleString() : '-';
});

const birthdayText = computed(() => {
  const b = birthday();
  return b > 0 ? b.toLocaleString() : '-';
});

const scanProgress = computed(() => {
  const b = birthday();
  const w = walletHeight();
  const c = chainHeight();
  if (c <= b) return '0%';
  return ((w - b) / (c - b) * 100) + '%';
});

const verifiedProgress = computed(() => {
  const p = provenHeight();
  const c = chainHeight();
  if (c === 0) return '0%';
  return Math.min(100, (p / c * 100)) + '%';
});

const balance = computed(() => {
  const n = notes();
  const s = spent();
  const unspent = n.filter(note => !s.includes(note.nullifier));
  const bal = unspent.reduce((sum, note) => sum + BigInt(note.value), 0n);
  return (Number(bal) / 1e8).toFixed(8);
});

// Computed visibility states
const hasWallet = computed(() => walletKeys() !== null);
const showWalletSection = computed(() => connected());
const showSyncSection = computed(() => hasWallet());
const showBalanceSection = computed(() => hasWallet());
// Show security section when syncing, or when we have verified proofs, or when gigaproof is available
const showSecuritySection = computed(() => hasWallet() && (scanning() || proofsVerified() > 0 || gigaproofHeight() > 0));

// ============== REACTIVE BINDINGS ==============
function setupBindings() {
  // Status displays with dynamic classes
  effect(() => {
    $('connect-status').textContent = connectStatus();
    $('connect-status').className = 'status' + (connectStatusClass() ? ' ' + connectStatusClass() : '');
  });

  effect(() => {
    $('wallet-status').textContent = walletStatus();
    $('wallet-status').className = 'status' + (walletStatusClass() ? ' ' + walletStatusClass() : '');
  });

  effect(() => {
    $('sync-status').textContent = syncStatus();
    $('sync-status').className = 'status' + (syncStatusClass() ? ' ' + syncStatusClass() : '');
  });

  // Height displays - auto-update
  bindText('chain-height', chainHeightText);
  bindText('proven-height', provenHeightText);
  bindText('birthday-height', birthdayText);
  bindText('wallet-height', walletHeightText);

  // Progress bars - auto-update
  bindStyle('progress', 'width', scanProgress);
  bindStyle('progress-verified', 'width', verifiedProgress);

  // Section visibility - auto-update
  bindVisible('wallet-section', showWalletSection);
  bindVisible('sync-section', showSyncSection);
  bindVisible('balance-section', showBalanceSection);
  bindVisible('security-section', showSecuritySection);
  bindVisible('proof-details', showProofDetails);

  // Sync/stop button visibility
  effect(() => {
    if (scanning()) {
      $('sync-btn').classList.add('hidden');
      $('stop-btn').classList.remove('hidden');
    } else {
      $('sync-btn').classList.remove('hidden');
      $('stop-btn').classList.add('hidden');
    }
  });

  // Balance display - auto-update
  effect(() => {
    $('balance').innerHTML = balance() + ' <span>ZEC</span>';
  });

  // Notes list - auto-update
  effect(() => {
    const n = notes();
    const s = spent();
    const list = $('notes');

    if (n.length === 0) {
      list.innerHTML = '<div style="color: var(--dim); padding: 8px;">no notes found</div>';
    } else {
      list.innerHTML = n.map(note => {
        const isSpent = s.includes(note.nullifier);
        const val = (Number(note.value) / 1e8).toFixed(8);
        return `<div class="note ${isSpent ? 'spent' : ''}">
          <span>#${note.height}</span>
          <span class="amount">${isSpent ? '-' : '+'}${val}</span>
        </div>`;
      }).join('');
    }
  });

  // Security layers - auto-update with fine-grained reactivity
  effect(() => {
    const el = $('sec-ligerito');
    el.classList.remove('active', 'verified', 'unavailable');
    const s = ligeritoStatus();
    if (s === 'active') el.classList.add('active');
    else if (s === 'verified') el.classList.add('verified');
    else if (s === 'unavailable') el.classList.add('unavailable');
    $('sec-ligerito-status').textContent = ligeritoDetail();
  });

  effect(() => {
    const el = $('sec-zanchor');
    el.classList.remove('active', 'verified', 'unavailable');
    const s = zanchorStatus();
    if (s === 'active') el.classList.add('active');
    else if (s === 'verified') el.classList.add('verified');
    else if (s === 'unavailable') el.classList.add('unavailable');
    $('sec-zanchor-status').textContent = zanchorDetail();
  });

  effect(() => {
    const el = $('sec-nomt');
    el.classList.remove('active', 'verified', 'unavailable');
    const s = nomtStatus();
    if (s === 'active') el.classList.add('active');
    else if (s === 'verified') el.classList.add('verified');
    else if (s === 'unavailable') el.classList.add('unavailable');
    $('sec-nomt-status').textContent = nomtDetail();
  });

  // Proof details - auto-update
  bindText('proof-giga-range', proofRange);
  effect(() => {
    $('proof-tip-hash').textContent = proofTipHash();
    $('proof-tip-hash').title = proofTipHash();
  });
  bindText('proof-work', proofWork);
  effect(() => {
    $('proof-continuity').textContent = proofContinuity();
    $('proof-continuity').className = proofContinuityClass();
  });
  effect(() => {
    $('proof-nomt-root').textContent = proofNomtRoot();
    $('proof-nomt-root').className = proofNomtRootClass();
  });
  bindText('proof-state-epoch', proofStateEpoch);
}

// Init WASM
async function init() {
  // Set up reactive bindings FIRST so UI updates work
  setupBindings();

  setConnectStatus('loading wasm...');

  try {
    await Promise.all([initWasm(), initLigerito()]);
    const threads = navigator.hardwareConcurrency || 4;
    try {
      const poolInits = [];
      if (zafuWasm.initThreadPool) poolInits.push(zafuWasm.initThreadPool(threads));
      if (ligerito.initThreadPool) poolInits.push(ligerito.initThreadPool(threads));
      if (poolInits.length > 0) await Promise.all(poolInits);
    } catch (e) {
      console.warn('thread pool failed:', e);
    }
    setConnectStatus(`zafu ${version()} ready (${num_threads()} threads)`);
  } catch (e) {
    setConnectStatus('wasm failed: ' + e.message);
    setConnectStatusClass('err');
  }
}

// Connect
$('connect-btn').onclick = async () => {
  const url = $('server-url').value.trim();
  setConnectStatus('connecting...');
  setConnectStatusClass('active');

  try {
    const resp = await grpc(url, 'GetSyncStatus', {});

    batch(() => {
      setConnected(true);
      setServerUrl(url);
      setChainHeight(resp.currentHeight);
      setGigaproofHeight(resp.lastGigaproofHeight || 0);
    });

    const proofStatus = resp.lastGigaproofHeight > 0
      ? `proven to ${resp.lastGigaproofHeight.toLocaleString()}`
      : 'generating proof...';

    setConnectStatus(`connected - height ${resp.currentHeight.toLocaleString()}, ${proofStatus}`);
    setConnectStatusClass('ok');

    // Poll for updates and continuously verify new tip proofs
    setInterval(async () => {
      if (!connected()) return;
      try {
        const r = await grpc(serverUrl(), 'GetSyncStatus', {});
        const oldChainHeight = chainHeight();
        const newChainHeight = r.currentHeight;

        batch(() => {
          setChainHeight(newChainHeight);
          setGigaproofHeight(r.lastGigaproofHeight || 0);
        });

        // If chain advanced and we have verified proofs, verify new tip
        if (newChainHeight > oldChainHeight && proofsVerified() > 0 && !scanning()) {
          const currentVerified = verifiedHeight();
          if (newChainHeight > currentVerified) {
            console.log(`[poll] chain advanced ${oldChainHeight} -> ${newChainHeight}, verifying new tip...`);
            setLigeritoDetail('new tip...');

            // Fetch fresh proof covering up to new tip
            const proof = await fetchHeaderProof(1, newChainHeight);
            if (proof && proof.ligerito_proof?.length > 0) {
              const ok = await verifyHeaderProof(proof);
              if (ok) {
                // Update verified height from tip proof
                const tipEnd = proof.tip_proof_outputs?.end_height || newChainHeight;
                setVerifiedHeight(tipEnd);
                setProofsVerified(proofsVerified() + 1);
                setLigeritoDetail(`tip ${tipEnd.toLocaleString()} ✓`);
                updateProofDetails(proof);
                console.log(`[poll] continuous verification OK: ${tipEnd}`);
              }
            }
          }
        }
      } catch (e) {
        console.warn('[poll] error:', e);
      }
    }, 10000);  // Check every 10s

  } catch (e) {
    setConnectStatus('failed: ' + e.message);
    setConnectStatusClass('err');
  }
};

// Import wallet
$('import-btn').onclick = async () => {
  const seed = $('seed-phrase').value.trim();
  const birthdayHeight = parseInt($('birthday').value) || 1687104;

  if (!validate_seed_phrase(seed)) {
    setWalletStatus('invalid seed phrase');
    setWalletStatusClass('err');
    return;
  }

  try {
    const keys = new WalletKeys(seed);
    const addr = keys.get_address();

    batch(() => {
      setWalletKeys(keys);
      setWalletHeight(birthdayHeight);
      setBirthday(birthdayHeight);
      setNotes([]);
      setSpent([]);
    });

    setWalletStatus(`imported: ${addr.slice(0,16)}...`);
    setWalletStatusClass('ok');
    // UI updates automatically via bindings!

  } catch (e) {
    setWalletStatus('error: ' + e.message);
    setWalletStatusClass('err');
  }
};

// Sync
$('sync-btn').onclick = async () => {
  if (!walletKeys() || scanning()) return;

  setScanning(true);

  const start = walletHeight();
  const end = chainHeight();
  const total = end - start;

  if (total <= 0) {
    setSyncStatus('already synced');
    finishSync();
    return;
  }

  let scanned = 0;
  let actions = 0;
  let found = 0;
  const batchSize = 200;
  const startTime = performance.now();

  batch(() => {
    setSyncStatusClass('active');
    setVerifiedHeight(start);
    setProofsVerified(0);
    setNullifiersObserved(0);
  });

  console.log(`[sync] starting scan from ${start} to ${end} (${total} blocks)`);

  // Initialize security layers
  setSecurityLayer('ligerito', 'active', 'starting...');
  setSecurityLayer('zanchor', 'none', 'checking...');
  setSecurityLayer('nomt', 'active', 'scanning...');

  // Fetch checkpoint to check Zanchor (Polkadot) status
  try {
    const checkpoint = await fetchCheckpoint();
    if (checkpoint && checkpoint.epoch > 0) {
      setSecurityLayer('zanchor', 'verified', `epoch ${checkpoint.epoch}`);
    } else {
      setSecurityLayer('zanchor', 'unavailable', 'awaiting finality');
    }
  } catch (e) {
    console.warn('[checkpoint] fetch error:', e);
    setSecurityLayer('zanchor', 'unavailable', 'not connected');
  }

  // Start verification in background (non-blocking) while scanning blocks
  const currentGigaproofHeight = gigaproofHeight();
  console.log(`[verify] gigaproofHeight=${currentGigaproofHeight}, start=${start}`);

  if (currentGigaproofHeight > start) {
    const provenTo = Math.min(currentGigaproofHeight, end);
    setSecurityLayer('ligerito', 'active', 'fetching...');

    // Run verification in background - don't block block scanning
    (async () => {
      try {
        console.log(`[verify] starting background verification: fetching proof 1->${currentGigaproofHeight}...`);
        const headerProof = await fetchHeaderProof(1, currentGigaproofHeight);
        console.log(`[verify] fetchHeaderProof returned:`, headerProof ? `${headerProof.ligerito_proof?.length || 0} bytes` : 'null');

        if (headerProof && headerProof.ligerito_proof && headerProof.ligerito_proof.length > 0) {
          setSecurityLayer('ligerito', 'active', 'verifying...');
          const startVerify = performance.now();
          const ok = await verifyHeaderProofAndUpdate(headerProof, provenTo);
          const elapsed = ((performance.now() - startVerify) / 1000).toFixed(1);

          if (ok) {
            const status = buildVerifyStatus(headerProof, elapsed);
            setSecurityLayer('ligerito', 'verified', status);
            console.log(`[verify] background verification complete: ${status}`);
          } else {
            console.warn('[verify] verification failed');
            setSecurityLayer('ligerito', 'unavailable', 'failed');
          }
        } else {
          console.log('[verify] no proof data in response');
          setSecurityLayer('ligerito', 'active', 'awaiting proof...');
        }
      } catch (e) {
        console.error('[verify] background verify error:', e);
        setSecurityLayer('ligerito', 'unavailable', `error: ${e.message}`);
      }
    })();  // Fire and forget
  } else {
    console.log(`[verify] skipping verification: gigaproofHeight(${currentGigaproofHeight}) <= start(${start})`);
    setSecurityLayer('ligerito', 'active', 'awaiting proof...');
  }

  // Block scanning loop
  const keys = walletKeys();
  let currentNotes = [...notes()];
  let currentSpent = [...spent()];
  let nfCount = 0;

  for (let h = start; h <= end && scanning(); h += batchSize) {
    const batchEnd = Math.min(h + batchSize - 1, end);

    try {
      const blocks = await fetchBlocks(h, batchEnd);
      const batchActions = blocks.reduce((sum, b) => sum + b.actions.length, 0);
      if (batchActions > 0) {
        console.log(`[batch ${h}-${batchEnd}] ${blocks.length} blocks, ${batchActions} actions`);
      }

      for (const block of blocks) {
        if (!scanning()) break;  // Check stop flag

        actions += block.actions.length;

        // Build binary for parallel scan
        if (block.actions.length > 0 && keys) {
          const binary = buildBinaryActions(block.actions);
          try {
            const foundNotes = keys.scan_actions_parallel(binary);
            if (foundNotes && foundNotes.length > 0) {
              found += foundNotes.length;
              console.log(`[block ${block.height}] found ${foundNotes.length} notes!`, foundNotes);
              for (const n of foundNotes) {
                currentNotes.push({ ...n, height: block.height });
              }
            }
          } catch (e) {
            console.warn('scan error at block', block.height, ':', e);
          }
        }

        // Track nullifiers
        for (const a of block.actions) {
          if (a.nullifier && a.nullifier.length === 32) {
            nfCount++;
            const nf = bytesToHex(a.nullifier);
            if (currentNotes.find(n => n.nullifier === nf)) {
              currentSpent.push(nf);
            }
          }
        }

        setWalletHeight(block.height);
      }

      if (!scanning()) break;  // Exit outer loop too

      scanned += blocks.length;
      const scanPct = (scanned / total) * 100;
      const elapsed = (performance.now() - startTime) / 1000;
      const rate = Math.round(actions / elapsed);

      // Update state - signals handle UI updates
      batch(() => {
        setNullifiersObserved(nfCount);
        setNotes([...currentNotes]);
        setSpent([...currentSpent]);
      });

      setSyncStatus(`${scanPct.toFixed(1)}% | ${actions.toLocaleString()} actions (${rate}/s) | ${found} notes`);

    } catch (e) {
      setSyncStatus('error: ' + e.message);
      setSyncStatusClass('err');
      break;
    }

    // Yield to event loop
    await new Promise(r => setTimeout(r, 10));
  }

  // Check if we were stopped
  const wasStopped = !scanning();

  // At end, try to verify tip proof for blocks beyond gigaproof (if not stopped)
  if (!wasStopped && walletHeight() > gigaproofHeight()) {
    setSyncStatus('verifying tip proof...');
    try {
      const proof = await fetchHeaderProof(gigaproofHeight() + 1, walletHeight());
      if (proof && proof.ligerito_proof?.length > 0) {
        const ok = await verifyHeaderProofAndUpdate(proof, walletHeight());
        if (ok) {
          setProofsVerified(proofsVerified() + 1);
          console.log(`[verify] tip proof verified!`);
        }
      }
    } catch (e) {
      console.warn('[verify] tip proof failed:', e);
    }
  }

  finishSync(wasStopped);
};

$('stop-btn').onclick = () => {
  setScanning(false);
  setSyncStatus('stopping...');
  console.log('[sync] stop requested by user');
};

// Helper: set security layer via signals
function setSecurityLayer(layer, status, detail) {
  if (layer === 'ligerito') {
    setLigeritoStatus(status);
    setLigeritoDetail(detail || (status === 'verified' ? '✓' : '-'));
  } else if (layer === 'zanchor') {
    setZanchorStatus(status);
    setZanchorDetail(detail || (status === 'verified' ? '✓' : '-'));
  } else if (layer === 'nomt') {
    setNomtStatus(status);
    setNomtDetail(detail || (status === 'verified' ? '✓' : '-'));
  }
}

// Helper: verify proof and update signals
async function verifyHeaderProofAndUpdate(headerProof, fallbackHeight) {
  // Cache proof data for download feature
  if (headerProof && headerProof.ligerito_proof) {
    lastProofData = headerProof;
  }

  const ok = await verifyHeaderProof(headerProof);

  if (ok) {
    const continuityOk = headerProof.continuity_verified;
    const hasTip = headerProof.tip_proof_outputs !== null;

    // Determine actual proven height
    let actualProvenHeight = fallbackHeight;
    if (hasTip && continuityOk && headerProof.tip_proof_outputs.end_height > 0) {
      actualProvenHeight = headerProof.tip_proof_outputs.end_height;
    } else if (headerProof.gigaproof_outputs?.end_height > 0) {
      actualProvenHeight = headerProof.gigaproof_outputs.end_height;
    }

    // Log public outputs
    if (headerProof.gigaproof_outputs) {
      const go = headerProof.gigaproof_outputs;
      console.log(`[verify] gigaproof: ${go.start_height} -> ${go.end_height}, ${go.num_headers} headers`);
    }
    if (headerProof.tip_proof_outputs) {
      const to = headerProof.tip_proof_outputs;
      console.log(`[verify] tip_proof: ${to.start_height} -> ${to.end_height}, ${to.num_headers} headers`);
    }

    console.log(`[verify] proven height: ${actualProvenHeight} (fallback: ${fallbackHeight}, tip: ${headerProof.tip_proof_outputs?.end_height || 'none'})`);

    batch(() => {
      setVerifiedHeight(actualProvenHeight);
      setProofsVerified(proofsVerified() + 1);

      // Update NOMT status with nullifier root
      if (headerProof.nullifier_root && headerProof.nullifier_root.length === 32) {
        const nfRoot = bytesToHex(headerProof.nullifier_root);
        setServerNullifierRoot(nfRoot);
        setSecurityLayer('nomt', 'verified', `root: ${nfRoot.slice(0, 8)}...`);
      } else if (headerProof.gigaproof_outputs?.final_state_commitment) {
        setSecurityLayer('nomt', 'verified', 'state proven');
      }
    });

    updateProofDetails(headerProof);
  }

  return ok;
}

// Helper: build verify status string
function buildVerifyStatus(headerProof, elapsed) {
  const continuityOk = headerProof.continuity_verified;
  const hasTip = headerProof.tip_proof_outputs !== null;
  let status = `verified (${elapsed}s)`;
  if (hasTip) status += continuityOk ? ' ✓' : ' ⚠';
  return status;
}

async function finishSync(wasStopped = false) {
  const wasRunning = scanning();
  setScanning(false);
  setSyncStatusClass(wasStopped ? 'active' : 'ok');

  // If verification hasn't completed yet, try once more
  if (proofsVerified() === 0 && gigaproofHeight() > 0) {
    console.log('[finishSync] attempting proof verification...');
    setSecurityLayer('ligerito', 'active', 'verifying...');

    try {
      const headerProof = await fetchHeaderProof(1, gigaproofHeight());
      if (headerProof && headerProof.ligerito_proof && headerProof.ligerito_proof.length > 0) {
        const startVerify = performance.now();
        const ok = await verifyHeaderProofAndUpdate(headerProof, gigaproofHeight());
        const elapsed = ((performance.now() - startVerify) / 1000).toFixed(1);

        if (ok) {
          setSecurityLayer('ligerito', 'verified', buildVerifyStatus(headerProof, elapsed));
          console.log(`[finishSync] verification complete`);
        } else {
          setSecurityLayer('ligerito', 'unavailable', 'verify failed');
        }
      } else {
        setSecurityLayer('ligerito', 'active', 'no proof yet');
      }
    } catch (e) {
      console.error('[finishSync] verification error:', e);
      setSecurityLayer('ligerito', 'unavailable', 'error');
    }
  }

  // Show verification summary - computed provenHeight handles the logic
  const proofDesc = proofsVerified() > 0
    ? `chain proven (${proofsVerified()} zkp from genesis)`
    : 'chain verified';

  const nfCount = nullifiersObserved();
  const nfDesc = nfCount > 0 ? `, ${nfCount.toLocaleString()} nullifiers` : '';

  const statusPrefix = wasStopped ? 'stopped' : 'scan complete';
  setSyncStatus(`${statusPrefix} - ${proofDesc}${nfDesc}`);

  // Update NOMT status based on nullifier root availability
  const nfRoot = serverNullifierRoot();
  if (nfRoot) {
    setSecurityLayer('nomt', 'verified', `${nfCount.toLocaleString()} nfs`);
    console.log(`[nomt] verified: ${nfCount.toLocaleString()} nullifiers, root: ${nfRoot.slice(0, 8)}...`);
  } else if (proofsVerified() > 0) {
    setSecurityLayer('nomt', 'active', `${nfCount.toLocaleString()} nfs (no root)`);
  } else {
    setSecurityLayer('nomt', 'active', `${nfCount.toLocaleString()} nfs`);
  }
}

// Update proof details via signals - all reactive!
function updateProofDetails(headerProof) {
  const go = headerProof.gigaproof_outputs;
  const to = headerProof.tip_proof_outputs;

  setShowProofDetails(true);

  // Full proven range (gigaproof + tip if available)
  if (go) {
    const endHeight = (to && headerProof.continuity_verified) ? to.end_height : go.end_height;
    const totalHeaders = go.num_headers + (to?.num_headers || 0);
    const rangeInfo = to ? ` + ${to.num_headers.toLocaleString()} tip` : '';
    setProofRange(`${go.start_height.toLocaleString()} → ${endHeight.toLocaleString()} (${totalHeaders.toLocaleString()} headers${rangeInfo})`);
  }

  // Tip hash - use tip proof's tip_hash if available, else gigaproof's
  const actualTipHash = (to && headerProof.continuity_verified && to.tip_hash) ? to.tip_hash : go?.tip_hash;
  if (actualTipHash) {
    const tipHashHex = bytesToHex(actualTipHash);
    setProofTipHash(tipHashHex.slice(0, 16) + '...');
  }

  // Chain work (cumulative difficulty)
  if (go?.cumulative_difficulty) {
    const work = go.cumulative_difficulty;
    const formatted = work > 1000000000000n
      ? `${(Number(work) / 1e12).toFixed(2)}T`
      : work > 1000000000n
      ? `${(Number(work) / 1e9).toFixed(2)}B`
      : work.toLocaleString();
    setProofWork(formatted);
  }

  // Continuity verification
  if (to) {
    if (headerProof.continuity_verified) {
      setProofContinuity('✓ giga→tip linked');
      setProofContinuityClass('value ok');
    } else {
      setProofContinuity('✗ chain break!');
      setProofContinuityClass('value err');
    }
  } else {
    setProofContinuity('single proof');
    setProofContinuityClass('value');
  }

  // NOMT nullifier root
  if (headerProof.nullifier_root && headerProof.nullifier_root.length === 32) {
    const rootHex = bytesToHex(headerProof.nullifier_root);
    setProofNomtRoot(rootHex.slice(0, 16) + '...');
    setProofNomtRootClass('value hash ok');
    setServerNullifierRoot(rootHex);
    setSecurityLayer('nomt', 'verified', 'root verified');
    console.log(`[nomt] server nullifier root: ${rootHex.slice(0, 16)}...`);
  } else if (go?.final_state_commitment) {
    const rootHex = bytesToHex(go.final_state_commitment);
    setProofNomtRoot(rootHex.slice(0, 16) + '...');
    setProofNomtRootClass('value hash');
  } else {
    setProofNomtRoot('not available');
    setProofNomtRootClass('value hash');
  }

  // Epoch = end_height / 1024
  if (go?.end_height) {
    const epoch = Math.floor(go.end_height / 1024);
    setProofStateEpoch(`epoch ${epoch.toLocaleString()}`);
  } else {
    setProofStateEpoch('-');
  }
}

// Balance and notes are computed reactively via effects in setupBindings()
// No manual updateBalance() needed anymore!

// gRPC helpers
async function grpc(url, method, data) {
  const path = `${url}/zidecar.v1.Zidecar/${method}`;
  let body;

  if (method === 'GetSyncStatus' || method === 'GetTip') {
    body = new Uint8Array([0, 0, 0, 0, 0]);
  } else {
    throw new Error('unsupported method');
  }

  const resp = await fetch(path, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/grpc-web+proto',
      'Accept': 'application/grpc-web+proto',
      'x-grpc-web': '1',
    },
    body,
  });

  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

  const buf = new Uint8Array(await resp.arrayBuffer());
  if (buf.length < 5) throw new Error('empty response');

  const len = (buf[1] << 24) | (buf[2] << 16) | (buf[3] << 8) | buf[4];
  const msg = buf.slice(5, 5 + len);

  if (method === 'GetSyncStatus') return parseSyncStatus(msg);
  return {};
}

async function fetchBlocks(start, end) {
  const path = `${serverUrl()}/zidecar.v1.Zidecar/GetCompactBlocks`;
  console.log(`[fetch] requesting blocks ${start}-${end}`);

  // Encode BlockRange
  const parts = [];
  if (start > 0) { parts.push(0x08); parts.push(...varint(start)); }
  if (end > 0) { parts.push(0x10); parts.push(...varint(end)); }
  const msg = new Uint8Array(parts);

  const body = new Uint8Array(5 + msg.length);
  body[0] = 0;
  body[1] = (msg.length >> 24) & 0xff;
  body[2] = (msg.length >> 16) & 0xff;
  body[3] = (msg.length >> 8) & 0xff;
  body[4] = msg.length & 0xff;
  body.set(msg, 5);

  const resp = await fetch(path, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/grpc-web+proto',
      'Accept': 'application/grpc-web+proto',
      'x-grpc-web': '1',
    },
    body,
  });

  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

  const buf = new Uint8Array(await resp.arrayBuffer());
  const blocks = parseBlockStream(buf);
  const totalActions = blocks.reduce((sum, b) => sum + b.actions.length, 0);
  if (totalActions > 0 || blocks.length < 50) {
    console.log(`[fetch] got ${blocks.length} blocks, ${totalActions} total actions`);
  }
  return blocks;
}

function parseBlockStream(buf) {
  const blocks = [];
  let pos = 0;

  while (pos < buf.length) {
    if (pos + 5 > buf.length) break;
    if (buf[pos] === 0x80) break; // trailer

    const len = (buf[pos+1] << 24) | (buf[pos+2] << 16) | (buf[pos+3] << 8) | buf[pos+4];
    pos += 5;
    if (pos + len > buf.length) break;

    blocks.push(parseBlock(buf.slice(pos, pos + len)));
    pos += len;
  }

  return blocks;
}

function parseBlock(buf) {
  const block = { height: 0, hash: new Uint8Array(0), actions: [] };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 0) {
      let v = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        v |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      if (field === 1) block.height = v;
    } else if (wire === 2) {
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 2) block.hash = data;
      else if (field === 3) block.actions.push(parseAction(data));
      pos += len;
    } else break;
  }

  return block;
}

function parseAction(buf) {
  const a = { cmx: new Uint8Array(0), ephemeralKey: new Uint8Array(0), ciphertext: new Uint8Array(0), nullifier: new Uint8Array(0) };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 2) {
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 1) a.cmx = data;
      else if (field === 2) a.ephemeralKey = data;
      else if (field === 3) a.ciphertext = data;
      else if (field === 4) a.nullifier = data;
      pos += len;
    } else break;
  }

  return a;
}

function buildBinaryActions(actions) {
  const size = 32 + 32 + 32 + 52;
  const buf = new Uint8Array(4 + actions.length * size);
  const view = new DataView(buf.buffer);
  view.setUint32(0, actions.length, true);

  let off = 4;
  let valid = 0;
  for (const a of actions) {
    const hasNull = a.nullifier.length === 32;
    const hasCmx = a.cmx.length === 32;
    const hasEpk = a.ephemeralKey.length === 32;
    const hasCt = a.ciphertext.length >= 52;
    if (hasNull && hasCmx && hasEpk && hasCt) valid++;

    if (hasNull) buf.set(a.nullifier, off);
    off += 32;
    if (hasCmx) buf.set(a.cmx, off);
    off += 32;
    if (hasEpk) buf.set(a.ephemeralKey, off);
    off += 32;
    if (hasCt) buf.set(a.ciphertext.slice(0, 52), off);
    off += 52;
  }

  if (valid !== actions.length) {
    console.warn(`[build] only ${valid}/${actions.length} actions are complete`);
  }

  return buf;
}

function parseSyncStatus(buf) {
  const r = { currentHeight: 0, currentEpoch: 0, blocksInEpoch: 0, completeEpochs: 0, gigaproofStatus: 0, lastGigaproofHeight: 0 };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    if ((tag & 0x7) !== 0) break;

    let v = 0, s = 0;
    while (pos < buf.length) {
      const b = buf[pos++];
      v |= (b & 0x7f) << s;
      if (!(b & 0x80)) break;
      s += 7;
    }

    if (field === 1) r.currentHeight = v;
    else if (field === 2) r.currentEpoch = v;
    else if (field === 3) r.blocksInEpoch = v;
    else if (field === 4) r.completeEpochs = v;
    else if (field === 5) r.gigaproofStatus = v;
    else if (field === 7) r.lastGigaproofHeight = v;
  }

  return r;
}

// varint and bytesToHex imported from utils.js

// Fetch latest FROST checkpoint
async function fetchCheckpoint() {
  const path = `${serverUrl()}/zidecar.v1.Zidecar/GetCheckpoint`;
  console.log(`[checkpoint] fetching latest checkpoint`);

  // EpochRequest with epoch_index=0 (latest)
  const msg = new Uint8Array([0x08, 0x00]); // field 1, varint 0
  const body = new Uint8Array(5 + msg.length);
  body[0] = 0;
  body[1] = 0; body[2] = 0; body[3] = 0; body[4] = msg.length;
  body.set(msg, 5);

  try {
    const resp = await fetch(path, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/grpc-web+proto',
        'Accept': 'application/grpc-web+proto',
        'x-grpc-web': '1',
      },
      body,
    });

    if (!resp.ok) {
      console.warn(`[checkpoint] HTTP ${resp.status}`);
      return null;
    }

    const buf = new Uint8Array(await resp.arrayBuffer());
    if (buf.length < 5) return null;

    const len = (buf[1] << 24) | (buf[2] << 16) | (buf[3] << 8) | buf[4];
    const msgData = buf.slice(5, 5 + len);

    // Parse FrostCheckpoint - just extract epoch_index (field 1)
    const checkpoint = parseCheckpoint(msgData);
    console.log(`[checkpoint] got checkpoint epoch ${checkpoint.epoch}, height ${checkpoint.height}`);
    return checkpoint;

  } catch (e) {
    console.warn('[checkpoint] fetch failed:', e);
    return null;
  }
}

// Parse FrostCheckpoint protobuf (minimal)
function parseCheckpoint(buf) {
  const cp = { epoch: 0, height: 0, block_hash: null, tree_root: null };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 0) { // varint
      let v = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        v |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      if (field === 1) cp.epoch = v;
      else if (field === 2) cp.height = v;
    } else if (wire === 2) { // length-delimited
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 3) cp.block_hash = data;
      else if (field === 4) cp.tree_root = data;
      pos += len;
    } else {
      break;
    }
  }

  return cp;
}

// Fetch header proof for block range
async function fetchHeaderProof(fromHeight, toHeight) {
  const path = `${serverUrl()}/zidecar.v1.Zidecar/GetHeaderProof`;
  console.log(`[proof] requesting header proof ${fromHeight}-${toHeight} from ${path}`);

  // Encode ProofRequest: field 1 = from_height, field 2 = to_height
  const parts = [];
  if (fromHeight > 0) { parts.push(0x08); parts.push(...varint(fromHeight)); }
  if (toHeight > 0) { parts.push(0x10); parts.push(...varint(toHeight)); }
  const msg = new Uint8Array(parts);

  const body = new Uint8Array(5 + msg.length);
  body[0] = 0;
  body[1] = (msg.length >> 24) & 0xff;
  body[2] = (msg.length >> 16) & 0xff;
  body[3] = (msg.length >> 8) & 0xff;
  body[4] = msg.length & 0xff;
  body.set(msg, 5);

  try {
    const resp = await fetch(path, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/grpc-web+proto',
        'Accept': 'application/grpc-web+proto',
        'x-grpc-web': '1',
      },
      body,
    });

    if (!resp.ok) {
      console.warn(`[proof] HTTP ${resp.status}`);
      return null;
    }

    const buf = new Uint8Array(await resp.arrayBuffer());
    console.log(`[proof] received ${buf.length} bytes`);
    if (buf.length < 5) {
      console.warn('[proof] response too short');
      return null;
    }

    // Parse grpc-web frame
    const len = (buf[1] << 24) | (buf[2] << 16) | (buf[3] << 8) | buf[4];
    const msgData = buf.slice(5, 5 + len);

    // Parse HeaderProof - extract ligerito_proof (field 1, wire type 2)
    const proof = parseHeaderProof(msgData);
    const nfRootHex = proof.nullifier_root ? bytesToHex(proof.nullifier_root).slice(0, 16) + '...' : 'none';
    console.log(`[proof] got proof: ${proof.ligerito_proof?.length || 0} bytes, range ${proof.from_height}-${proof.to_height}, nf_root: ${nfRootHex}`);
    return proof;

  } catch (e) {
    console.warn('[proof] fetch failed:', e);
    return null;
  }
}

// Parse HeaderProof protobuf (updated with public outputs and nullifier root)
function parseHeaderProof(buf) {
  const proof = {
    ligerito_proof: null,
    from_height: 0,
    to_height: 0,
    tip_hash: null,
    gigaproof_outputs: null,
    tip_proof_outputs: null,
    continuity_verified: false,
    nullifier_root: null  // field 9 - NOMT nullifier set root
  };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 0) { // varint
      let v = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        v |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      if (field === 2) proof.from_height = v;
      else if (field === 3) proof.to_height = v;
      else if (field === 8) proof.continuity_verified = (v !== 0);
    } else if (wire === 2) { // length-delimited
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 1) proof.ligerito_proof = data;
      else if (field === 4) proof.tip_hash = data;
      else if (field === 6) proof.gigaproof_outputs = parsePublicOutputs(data);
      else if (field === 7) proof.tip_proof_outputs = parsePublicOutputs(data);
      else if (field === 9) proof.nullifier_root = data;  // NOMT root
      pos += len;
    } else {
      break; // unknown wire type
    }
  }

  return proof;
}

// Parse ProofPublicOutputs protobuf
function parsePublicOutputs(buf) {
  const outputs = {
    start_height: 0,
    end_height: 0,
    start_hash: null,
    start_prev_hash: null,
    tip_hash: null,
    tip_prev_hash: null,
    cumulative_difficulty: 0n,
    final_commitment: null,
    final_state_commitment: null,
    num_headers: 0
  };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 0) { // varint
      let v = 0n, s = 0n;
      while (pos < buf.length) {
        const b = BigInt(buf[pos++]);
        v |= (b & 0x7fn) << s;
        if (!(b & 0x80n)) break;
        s += 7n;
      }
      if (field === 1) outputs.start_height = Number(v);
      else if (field === 2) outputs.end_height = Number(v);
      else if (field === 7) outputs.cumulative_difficulty = v;
      else if (field === 10) outputs.num_headers = Number(v);
    } else if (wire === 2) { // length-delimited
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 3) outputs.start_hash = data;
      else if (field === 4) outputs.start_prev_hash = data;
      else if (field === 5) outputs.tip_hash = data;
      else if (field === 6) outputs.tip_prev_hash = data;
      else if (field === 8) outputs.final_commitment = data;
      else if (field === 9) outputs.final_state_commitment = data;
      pos += len;
    } else {
      break;
    }
  }

  return outputs;
}

// Parse a single proof: [public_outputs_len: u32][public_outputs...][log_size: u8][ligerito_proof...]
function parseSingleProof(bytes) {
  const publicLen = bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
  const proofStart = 4 + publicLen;

  if (bytes.length < proofStart + 1) {
    console.warn('[parse] proof truncated, publicLen:', publicLen, 'total:', bytes.length);
    return null;
  }

  const logSize = bytes[proofStart];
  const proofBytes = bytes.slice(proofStart + 1);

  return { publicLen, logSize, proofBytes };
}

// Verify header proof using ligerito - verifies BOTH gigaproof and tip proof
async function verifyHeaderProof(proof) {
  if (!proof || !proof.ligerito_proof || proof.ligerito_proof.length < 10) {
    console.warn('[verify] no proof to verify');
    return false;
  }

  try {
    // Combined format: [gigaproof_size: u32][gigaproof_bytes][tip_bytes]
    const bytes = proof.ligerito_proof;

    // Parse combined proof format
    const gigaproofSize = bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
    const gigaproofBytes = bytes.slice(4, 4 + gigaproofSize);
    const tipBytes = bytes.slice(4 + gigaproofSize);

    console.log(`[verify] combined: gigaproofSize=${gigaproofSize}, tipSize=${tipBytes.length}, total=${bytes.length}`);

    // Parse gigaproof
    const giga = parseSingleProof(gigaproofBytes);
    if (!giga) {
      console.warn('[verify] failed to parse gigaproof');
      return false;
    }

    // Parse tip proof (if present)
    let tip = null;
    if (tipBytes.length > 10) {
      tip = parseSingleProof(tipBytes);
      if (tip) {
        console.log(`[verify] tip proof: publicLen=${tip.publicLen}, logSize=${tip.logSize}, proofBytes=${tip.proofBytes.length}`);
      }
    }

    console.log(`[verify] gigaproof: publicLen=${giga.publicLen}, logSize=${giga.logSize}, proofBytes=${giga.proofBytes.length}`);

    // Supported config sizes in ligerito WASM
    const SUPPORTED_SIZES = new Set([12, 16, 20, 24, 26, 28, 30]);

    // Helper to verify a single proof
    async function verifySingle(parsed, name) {
      const { logSize, proofBytes } = parsed;
      const sizeDesc = `2^${logSize}`;

      // Check if this size is supported
      if (!SUPPORTED_SIZES.has(logSize)) {
        console.warn(`[verify] ${name} ${sizeDesc}: SKIPPED (size ${logSize} not supported by WASM verifier)`);
        setLigeritoDetail(`${name} 2^${logSize} (no verifier)`);
        return { ok: true, ms: '0', name, logSize, skipped: true };
      }

      setSyncStatus(`verifying ${name} ${sizeDesc}...`);
      setLigeritoDetail(`${name}...`);
      await new Promise(r => setTimeout(r, 20)); // Let UI update

      const start = performance.now();
      const ok = verifyProof(proofBytes, logSize, "sha256");
      const ms = (performance.now() - start).toFixed(0);

      console.log(`[verify] ${name} ${sizeDesc}: ${ok ? 'OK' : 'FAIL'} (${ms}ms)`);
      return { ok, ms, name, logSize, skipped: false };
    }

    // Verify BOTH proofs
    const results = [];

    // 1. Verify gigaproof (covers genesis → epoch boundary)
    const gigaResult = await verifySingle(giga, 'gigaproof');
    results.push(gigaResult);

    if (!gigaResult.ok) {
      setLigeritoDetail('gigaproof FAILED');
      return false;
    }

    // 2. Verify tip proof if present (covers epoch boundary → tip)
    if (tip) {
      const tipResult = await verifySingle(tip, 'tip');
      results.push(tipResult);

      if (!tipResult.ok) {
        setLigeritoDetail('tip FAILED');
        return false;
      }
    }

    // Summary
    const verified = results.filter(r => !r.skipped);
    const skipped = results.filter(r => r.skipped);
    const totalMs = verified.reduce((sum, r) => sum + parseInt(r.ms), 0);

    if (verified.length > 0) {
      const names = verified.map(r => `${r.name} 2^${r.logSize}`).join(', ');
      console.log(`[verify] VERIFIED: ${names} in ${totalMs}ms`);
    }
    if (skipped.length > 0) {
      const names = skipped.map(r => `${r.name} 2^${r.logSize}`).join(', ');
      console.log(`[verify] SKIPPED (no WASM verifier): ${names}`);
    }

    // Return true if at least one proof was verified (or all were skipped but valid)
    return true;

  } catch (e) {
    console.warn('[verify] verification failed:', e);
    return false;
  }
}

// ============== MODAL FUNCTIONS ==============

function openModal(layer) {
  const modal = document.getElementById(`modal-${layer}`);
  if (modal) {
    modal.classList.add('active');
    document.body.style.overflow = 'hidden';
  }
}

function closeModal(layer) {
  const modal = document.getElementById(`modal-${layer}`);
  if (modal) {
    modal.classList.remove('active');
    document.body.style.overflow = '';
  }
}

// Make closeModal globally available for onclick handlers
window.closeModal = closeModal;

// Close modal on overlay click (not modal content)
document.querySelectorAll('.modal-overlay').forEach(overlay => {
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) {
      overlay.classList.remove('active');
      document.body.style.overflow = '';
    }
  });
});

// Close modal on Escape key
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    document.querySelectorAll('.modal-overlay.active').forEach(modal => {
      modal.classList.remove('active');
    });
    document.body.style.overflow = '';
  }
});

// Security layer click handlers
$('sec-ligerito').addEventListener('click', () => {
  openModal('ligerito');
  updateProofInfo();  // Refresh proof sizes when opening
});
$('sec-zanchor').addEventListener('click', () => openModal('zanchor'));
$('sec-nomt').addEventListener('click', () => openModal('nomt'));

// Helper: parse combined proof format into gigaproof and tip proof
function parseProofParts(combinedBytes) {
  if (!combinedBytes || combinedBytes.length < 8) return null;

  const gigaproofSize = combinedBytes[0] | (combinedBytes[1] << 8) | (combinedBytes[2] << 16) | (combinedBytes[3] << 24);
  const gigaproofBytes = combinedBytes.slice(4, 4 + gigaproofSize);
  const tipBytes = combinedBytes.slice(4 + gigaproofSize);

  return {
    gigaproof: gigaproofBytes,
    tipproof: tipBytes.length > 10 ? tipBytes : null
  };
}

// Helper: download binary file
function downloadBlob(data, filename) {
  const blob = new Blob([data], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Helper: fetch and cache proof data
async function ensureProofData() {
  if (lastProofData && lastProofData.ligerito_proof) return lastProofData;

  const gHeight = gigaproofHeight();
  if (gHeight === 0) return null;

  lastProofData = await fetchHeaderProof(1, chainHeight());
  return lastProofData;
}

// Update proof info when modal opens
function updateProofInfo() {
  const info = $('proof-info');
  if (!lastProofData || !lastProofData.ligerito_proof) {
    info.textContent = 'Connect and sync to fetch proof data.';
    return;
  }

  const parts = parseProofParts(lastProofData.ligerito_proof);
  if (!parts) {
    info.textContent = 'Invalid proof format.';
    return;
  }

  const go = lastProofData.gigaproof_outputs;
  const to = lastProofData.tip_proof_outputs;

  let text = `Gigaproof: ${(parts.gigaproof.length / 1024).toFixed(1)} KB`;
  if (go) text += ` (blocks 1→${go.end_height.toLocaleString()})`;

  if (parts.tipproof) {
    text += ` | Tip: ${(parts.tipproof.length / 1024).toFixed(1)} KB`;
    if (to) text += ` (blocks ${to.start_height.toLocaleString()}→${to.end_height.toLocaleString()})`;
  } else {
    text += ' | Tip: not available';
  }

  info.innerHTML = text;
}

// Download gigaproof
$('download-gigaproof').addEventListener('click', async () => {
  const btn = $('download-gigaproof');
  const originalText = btn.textContent;

  try {
    btn.textContent = 'Fetching...';
    btn.disabled = true;

    const proof = await ensureProofData();
    if (!proof || !proof.ligerito_proof) {
      alert('No proof available yet. Please connect and sync first.');
      return;
    }

    const parts = parseProofParts(proof.ligerito_proof);
    if (!parts || !parts.gigaproof) {
      alert('Failed to parse proof data.');
      return;
    }

    const go = proof.gigaproof_outputs;
    const endHeight = go ? go.end_height : proof.to_height;
    downloadBlob(parts.gigaproof, `gigaproof-1-${endHeight}.bin`);

    btn.textContent = 'Downloaded!';
    setTimeout(() => { btn.textContent = originalText; }, 2000);

  } catch (e) {
    console.error('[download] gigaproof error:', e);
    alert('Failed to download: ' + e.message);
    btn.textContent = originalText;
  } finally {
    btn.disabled = false;
  }
});

// Download tip proof
$('download-tipproof').addEventListener('click', async () => {
  const btn = $('download-tipproof');
  const originalText = btn.textContent;

  try {
    btn.textContent = 'Fetching...';
    btn.disabled = true;

    const proof = await ensureProofData();
    if (!proof || !proof.ligerito_proof) {
      alert('No proof available yet. Please connect and sync first.');
      return;
    }

    const parts = parseProofParts(proof.ligerito_proof);
    if (!parts) {
      alert('Failed to parse proof data.');
      return;
    }

    if (!parts.tipproof) {
      alert('No tip proof available. The chain may be at an epoch boundary.');
      return;
    }

    const to = proof.tip_proof_outputs;
    const startHeight = to ? to.start_height : (proof.gigaproof_outputs?.end_height || 0) + 1;
    const endHeight = to ? to.end_height : proof.to_height;
    downloadBlob(parts.tipproof, `tipproof-${startHeight}-${endHeight}.bin`);

    btn.textContent = 'Downloaded!';
    setTimeout(() => { btn.textContent = originalText; }, 2000);

  } catch (e) {
    console.error('[download] tipproof error:', e);
    alert('Failed to download: ' + e.message);
    btn.textContent = originalText;
  } finally {
    btn.disabled = false;
  }
});

$('download-checkpoint').addEventListener('click', async () => {
  const btn = $('download-checkpoint');
  const originalText = btn.textContent;

  try {
    btn.textContent = 'Fetching...';
    btn.disabled = true;

    // Fetch checkpoint
    const checkpoint = await fetchCheckpoint();
    if (!checkpoint || checkpoint.epoch === 0) {
      alert('No checkpoint available yet. Zanchor parachain may be idle.');
      return;
    }

    // Create JSON representation
    const checkpointJson = JSON.stringify({
      epoch: checkpoint.epoch,
      height: checkpoint.height,
      block_hash: checkpoint.block_hash ? bytesToHex(checkpoint.block_hash) : null,
      tree_root: checkpoint.tree_root ? bytesToHex(checkpoint.tree_root) : null,
      timestamp: new Date().toISOString()
    }, null, 2);

    // Create download
    const blob = new Blob([checkpointJson], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `zanchor-checkpoint-epoch-${checkpoint.epoch}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    btn.textContent = 'Downloaded!';
    setTimeout(() => { btn.textContent = originalText; }, 2000);

  } catch (e) {
    console.error('[download] checkpoint error:', e);
    alert('Failed to download checkpoint: ' + e.message);
    btn.textContent = originalText;
  } finally {
    btn.disabled = false;
  }
});

// Paseo parachain verification (ParaId 5082)
$('verify-paseo').addEventListener('click', async () => {
  const btn = $('verify-paseo');
  const statusDiv = $('paseo-verify-status');
  const resultDiv = $('paseo-verify-result');
  const originalText = btn.textContent;

  const PASEO_RPC = 'wss://paseo.rpc.amforc.com:443';

  try {
    btn.textContent = 'Connecting...';
    btn.disabled = true;
    statusDiv.style.display = 'block';
    resultDiv.innerHTML = '<span style="color: var(--gold);">Connecting to Paseo relay chain...</span>';

    // First fetch local checkpoint from zidecar
    const checkpoint = await fetchCheckpoint();
    if (!checkpoint || checkpoint.epoch === 0) {
      resultDiv.innerHTML = '<span style="color: var(--err);">No local checkpoint available. Server may not have checkpoint data.</span>';
      return;
    }

    resultDiv.innerHTML = `<span style="color: var(--gold);">Local checkpoint: epoch ${checkpoint.epoch}, height ${checkpoint.height}</span><br><span style="color: var(--dim);">Querying Paseo parachain 5082...</span>`;

    // Query Paseo via JSON-RPC over HTTPS (simpler than WebSocket for verification)
    const paseoHttpRpc = 'https://paseo.rpc.amforc.com';

    // Query system_chain to verify connection
    const chainResp = await fetch(paseoHttpRpc, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 1,
        method: 'system_chain',
        params: []
      })
    });
    const chainData = await chainResp.json();

    if (chainData.result !== 'Paseo Testnet') {
      resultDiv.innerHTML = `<span style="color: var(--err);">Unexpected chain: ${chainData.result}</span>`;
      return;
    }

    // Query paras_info to check parachain 5082 status
    const parasResp = await fetch(paseoHttpRpc, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 2,
        method: 'state_getStorage',
        params: ['0x0d715f2646c8f85767b5d2764bb278265e44fd2e0c6e1e0ee9a1ec7b4f2c3bfe'] // paras.parachains storage key
      })
    });
    const parasData = await parasResp.json();

    // Get latest finalized block
    const finalizedResp = await fetch(paseoHttpRpc, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 3,
        method: 'chain_getFinalizedHead',
        params: []
      })
    });
    const finalizedData = await finalizedResp.json();
    const finalizedHash = finalizedData.result;

    // Get finalized block header for block number
    const headerResp = await fetch(paseoHttpRpc, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 4,
        method: 'chain_getHeader',
        params: [finalizedHash]
      })
    });
    const headerData = await headerResp.json();
    const finalizedHeight = parseInt(headerData.result?.number, 16) || 0;

    // Display verification results
    const localBlockHash = checkpoint.block_hash ? bytesToHex(checkpoint.block_hash) : 'N/A';
    const localTreeRoot = checkpoint.tree_root ? bytesToHex(checkpoint.tree_root) : 'N/A';

    resultDiv.innerHTML = `
      <div style="margin-bottom: 8px;">
        <strong style="color: var(--ok);">✓ Connected to Paseo Testnet</strong>
      </div>
      <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px 12px; font-size: 10px;">
        <span style="color: var(--dim);">Relay finalized:</span>
        <span style="font-family: monospace;">#${finalizedHeight.toLocaleString()}</span>
        <span style="color: var(--dim);">Relay head:</span>
        <span style="font-family: monospace; overflow: hidden; text-overflow: ellipsis;">${finalizedHash.slice(0, 18)}...</span>
        <span style="color: var(--dim);">ParaId:</span>
        <span style="font-family: monospace;">5082 (zanchor)</span>
        <span style="color: var(--dim);">Local epoch:</span>
        <span style="font-family: monospace;">${checkpoint.epoch}</span>
        <span style="color: var(--dim);">Zcash height:</span>
        <span style="font-family: monospace;">${checkpoint.height.toLocaleString()}</span>
        <span style="color: var(--dim);">Block hash:</span>
        <span style="font-family: monospace; overflow: hidden; text-overflow: ellipsis;">${localBlockHash.slice(0, 18)}...</span>
      </div>
      <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border); font-size: 10px; color: var(--dim);">
        Note: Full checkpoint verification requires querying zanchor parachain (5082) storage directly. Parachain is on-demand (parathread) - active when blocks produced.
      </div>
    `;

    btn.textContent = 'Verified!';
    setTimeout(() => { btn.textContent = originalText; }, 3000);

  } catch (e) {
    console.error('[paseo] verification error:', e);
    resultDiv.innerHTML = `<span style="color: var(--err);">Verification failed: ${e.message}</span>`;
    btn.textContent = originalText;
  } finally {
    btn.disabled = false;
  }
});

$('download-nomt-root').addEventListener('click', async () => {
  const btn = $('download-nomt-root');
  const originalText = btn.textContent;

  try {
    btn.textContent = 'Fetching...';
    btn.disabled = true;

    // Get NOMT root from last proof or fetch fresh
    let nomtRoot = serverNullifierRoot();
    let provenTo = provenHeight();

    if (!nomtRoot && gigaproofHeight() > 0) {
      const proof = await fetchHeaderProof(1, gigaproofHeight());
      if (proof && proof.nullifier_root) {
        nomtRoot = bytesToHex(proof.nullifier_root);
        provenTo = proof.to_height;
      }
    }

    if (!nomtRoot) {
      alert('No NOMT root available yet. Please sync first.');
      return;
    }

    // Create JSON representation
    const stateJson = JSON.stringify({
      nullifier_root: nomtRoot,
      proven_height: provenTo,
      nullifiers_observed: nullifiersObserved(),
      timestamp: new Date().toISOString()
    }, null, 2);

    // Create download
    const blob = new Blob([stateJson], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `nomt-state-height-${provenTo}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    btn.textContent = 'Downloaded!';
    setTimeout(() => { btn.textContent = originalText; }, 2000);

  } catch (e) {
    console.error('[download] nomt state error:', e);
    alert('Failed to download state: ' + e.message);
    btn.textContent = originalText;
  } finally {
    btn.disabled = false;
  }
});

init();
</script>
</body>
</html>
