<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>zafu | zcash wallet</title>
<meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
<meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --bg: #0d0d12;
  --surface: #16161d;
  --border: #2a2a35;
  --gold: #f4a31e;
  --text: #e0e0e4;
  --dim: #707078;
  --ok: #50c878;
  --err: #c05050;
}
body {
  background: var(--bg);
  color: var(--text);
  font-family: 'SF Mono', 'Consolas', monospace;
  font-size: 13px;
  line-height: 1.6;
  padding: 24px;
  min-height: 100vh;
}
.container {
  max-width: 700px;
  margin: 0 auto;
}
h1 {
  color: var(--gold);
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 24px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border);
}
.section {
  margin-bottom: 24px;
  padding: 16px;
  background: var(--surface);
  border: 1px solid var(--border);
}
.section-title {
  color: var(--dim);
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 12px;
}
.row {
  display: flex;
  gap: 12px;
  align-items: center;
  margin-bottom: 8px;
}
.row:last-child { margin-bottom: 0; }
input, textarea, select {
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  padding: 8px 12px;
  font-family: inherit;
  font-size: 12px;
  flex: 1;
}
input:focus, textarea:focus {
  outline: none;
  border-color: var(--gold);
}
textarea { min-height: 60px; resize: vertical; }
button {
  background: var(--gold);
  color: #000;
  border: none;
  padding: 8px 16px;
  font-family: inherit;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  cursor: pointer;
}
button:hover { filter: brightness(1.1); }
button:disabled { background: var(--border); color: var(--dim); cursor: not-allowed; }
.status {
  padding: 12px;
  background: var(--bg);
  border-left: 3px solid var(--border);
  font-size: 12px;
  white-space: pre-wrap;
  word-wrap: break-word;
  min-height: 40px;
}
.status.ok { border-color: var(--ok); }
.status.err { border-color: var(--err); }
.status.active { border-color: var(--gold); }
.progress-bar {
  height: 8px;
  background: var(--bg);
  margin: 12px 0;
  overflow: hidden;
  position: relative;
}
.progress-fill {
  height: 100%;
  background: var(--gold);
  width: 0%;
  transition: width 0.2s;
  position: absolute;
  top: 0;
  left: 0;
}
.progress-verified {
  height: 100%;
  background: var(--ok);
  width: 0%;
  transition: width 0.2s;
  position: absolute;
  top: 0;
  left: 0;
}
.progress-legend {
  display: flex;
  gap: 16px;
  font-size: 10px;
  margin-top: 4px;
}
.progress-legend span::before {
  content: '';
  display: inline-block;
  width: 8px;
  height: 8px;
  margin-right: 4px;
  vertical-align: middle;
}
.legend-synced::before { background: var(--gold); }
.legend-verified::before { background: var(--ok); }
.balance {
  font-size: 28px;
  font-weight: 600;
  color: var(--gold);
  text-align: center;
  padding: 20px;
}
.balance span { font-size: 14px; color: var(--dim); }
.info-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  font-size: 12px;
}
.info-grid .label { color: var(--dim); }
.info-grid .value { text-align: right; }
.hidden { display: none; }
.note-list {
  max-height: 150px;
  overflow-y: auto;
  font-size: 11px;
}
.note {
  padding: 6px 0;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
}
.note:last-child { border-bottom: none; }
.note.spent { opacity: 0.5; }
.note .amount { color: var(--ok); }
.note.spent .amount { color: var(--err); }
.security-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}
.security-layer {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  background: var(--bg);
  border-left: 2px solid var(--border);
}
.security-layer.active { border-color: var(--gold); }
.security-layer.verified { border-color: var(--ok); }
.security-layer.unavailable { opacity: 0.5; }
.sec-icon {
  font-size: 16px;
  width: 20px;
  text-align: center;
  color: var(--dim);
}
.security-layer.active .sec-icon,
.security-layer.verified .sec-icon { color: var(--gold); }
.sec-info { flex: 1; min-width: 0; }
.sec-name { font-size: 11px; font-weight: 600; }
.sec-desc { font-size: 9px; color: var(--dim); }
.sec-status {
  font-size: 9px;
  color: var(--dim);
  text-align: right;
  white-space: nowrap;
}
.security-layer.verified .sec-status { color: var(--ok); }
.proof-details {
  margin-top: 12px;
  padding: 10px;
  background: var(--bg);
  font-size: 11px;
}
.proof-title {
  color: var(--dim);
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}
.proof-grid {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 4px 12px;
}
.proof-grid .label { color: var(--dim); }
.proof-grid .value { text-align: right; font-family: monospace; }
.proof-grid .value.hash { font-size: 10px; overflow: hidden; text-overflow: ellipsis; }
.proof-grid .value.ok { color: var(--ok); }
.proof-grid .value.err { color: var(--err); }
</style>
</head>
<body>
<div class="container">
<h1>zafu <span style="color: var(--dim); font-weight: 400">zcash light wallet</span></h1>

<div class="section">
  <div class="section-title">server</div>
  <div class="row">
    <input type="text" id="server-url" value="http://localhost:50051" placeholder="zidecar server">
    <button id="connect-btn">connect</button>
  </div>
  <div class="status" id="connect-status">not connected</div>
</div>

<div class="section hidden" id="wallet-section">
  <div class="section-title">wallet</div>
  <div class="row">
    <textarea id="seed-phrase" placeholder="enter 24-word seed phrase"></textarea>
  </div>
  <div class="row">
    <input type="number" id="birthday" value="1687104" min="1" placeholder="birthday height">
    <button id="import-btn">import</button>
  </div>
  <div class="status" id="wallet-status">enter seed phrase
<span style="color: var(--dim); font-size: 11px">note: orchard only (post-NU5). sapling transactions not supported.</span></div>
</div>

<div class="section hidden" id="sync-section">
  <div class="section-title">sync</div>
  <div class="info-grid" id="sync-info">
    <span class="label">chain</span><span class="value" id="chain-height">-</span>
    <span class="label">wallet</span><span class="value" id="wallet-height">-</span>
    <span class="label">remaining</span><span class="value" id="remaining">-</span>
    <span class="label">verified</span><span class="value" id="verified-count">0</span>
  </div>
  <div class="progress-bar">
    <div class="progress-fill" id="progress"></div>
    <div class="progress-verified" id="progress-verified"></div>
  </div>
  <div class="progress-legend">
    <span class="legend-synced">synced</span>
    <span class="legend-verified">verified (zkp)</span>
  </div>
  <div class="row">
    <button id="sync-btn">sync</button>
    <button id="stop-btn" class="hidden">stop</button>
  </div>
  <div class="status" id="sync-status">ready to sync</div>
</div>

<div class="section hidden" id="security-section">
  <div class="section-title">security layers</div>
  <div class="security-grid" style="grid-template-columns: 1fr 1fr 1fr;">
    <div class="security-layer" id="sec-ligerito">
      <div class="sec-icon">◈</div>
      <div class="sec-info">
        <div class="sec-name">Ligerito</div>
        <div class="sec-desc">header chain ZKP</div>
      </div>
      <div class="sec-status" id="sec-ligerito-status">-</div>
    </div>
    <div class="security-layer" id="sec-zanchor">
      <div class="sec-icon">●</div>
      <div class="sec-info">
        <div class="sec-name">Zanchor</div>
        <div class="sec-desc">polkadot finality</div>
      </div>
      <div class="sec-status" id="sec-zanchor-status">-</div>
    </div>
    <div class="security-layer" id="sec-nomt">
      <div class="sec-icon">⌘</div>
      <div class="sec-info">
        <div class="sec-name">NOMT</div>
        <div class="sec-desc">state proof</div>
      </div>
      <div class="sec-status" id="sec-nomt-status">-</div>
    </div>
  </div>
  <div class="proof-details hidden" id="proof-details">
    <div class="proof-title">proof verification</div>
    <div class="proof-grid">
      <span class="label">gigaproof</span><span class="value" id="proof-giga-range">-</span>
      <span class="label">tip_hash</span><span class="value hash" id="proof-tip-hash">-</span>
      <span class="label">chain work</span><span class="value" id="proof-work">-</span>
      <span class="label">continuity</span><span class="value" id="proof-continuity">-</span>
    </div>
  </div>
</div>

<div class="section hidden" id="balance-section">
  <div class="section-title">balance</div>
  <div class="balance" id="balance">0.00000000 <span>ZEC</span></div>
  <div class="note-list" id="notes"></div>
</div>

</div>

<script type="module">
import initWasm, { WalletKeys, validate_seed_phrase, version, num_threads } from './pkg/zafu_wasm.js';
import * as zafuWasm from './pkg/zafu_wasm.js';
import initLigerito, { verify as verifyProof } from './ligerito.js';
import * as ligerito from './ligerito.js';

const $ = id => document.getElementById(id);
const state = {
  connected: false,
  serverUrl: '',
  chainHeight: 0,
  walletHeight: 0,
  walletKeys: null,
  scanning: false,
  notes: [],
  spent: [],
  // verification state
  gigaproofHeight: 0,       // height covered by gigaproof
  verifiedHeight: 0,        // height we've verified up to
  proofsVerified: 0,        // count of proofs verified
  // security layers
  security: {
    ligerito: { status: 'none', detail: '' },
    zanchor: { status: 'none', detail: '' },
    nomt: { status: 'none', detail: '' },
  },
};

// Init WASM
async function init() {
  $('connect-status').textContent = 'loading wasm...';
  try {
    await Promise.all([initWasm(), initLigerito()]);
    const threads = navigator.hardwareConcurrency || 4;
    try {
      const poolInits = [];
      if (zafuWasm.initThreadPool) poolInits.push(zafuWasm.initThreadPool(threads));
      if (ligerito.initThreadPool) poolInits.push(ligerito.initThreadPool(threads));
      if (poolInits.length > 0) await Promise.all(poolInits);
    } catch (e) {
      console.warn('thread pool failed:', e);
    }
    $('connect-status').textContent = `zafu ${version()} ready (${num_threads()} threads)`;
  } catch (e) {
    $('connect-status').textContent = 'wasm failed: ' + e.message;
    $('connect-status').className = 'status err';
  }
}

// Connect
$('connect-btn').onclick = async () => {
  const url = $('server-url').value.trim();
  $('connect-status').textContent = 'connecting...';
  $('connect-status').className = 'status active';

  try {
    const resp = await grpc(url, 'GetSyncStatus', {});
    state.connected = true;
    state.serverUrl = url;
    state.chainHeight = resp.currentHeight;
    state.gigaproofHeight = resp.lastGigaproofHeight || 0;

    const proofStatus = resp.lastGigaproofHeight > 0
      ? `proven to ${resp.lastGigaproofHeight.toLocaleString()}`
      : 'generating proof...';
    $('connect-status').textContent = `connected - height ${resp.currentHeight.toLocaleString()}, ${proofStatus}`;
    $('connect-status').className = 'status ok';
    $('chain-height').textContent = resp.currentHeight.toLocaleString();
    $('wallet-section').classList.remove('hidden');

    // Poll for updates
    setInterval(async () => {
      if (!state.connected) return;
      try {
        const r = await grpc(state.serverUrl, 'GetSyncStatus', {});
        state.chainHeight = r.currentHeight;
        state.gigaproofHeight = r.lastGigaproofHeight || 0;
        $('chain-height').textContent = r.currentHeight.toLocaleString();
        if (!state.scanning) {
          $('remaining').textContent = Math.max(0, r.currentHeight - state.walletHeight).toLocaleString();
        }
      } catch (e) {}
    }, 15000);

  } catch (e) {
    $('connect-status').textContent = 'failed: ' + e.message;
    $('connect-status').className = 'status err';
  }
};

// Import wallet
$('import-btn').onclick = async () => {
  const seed = $('seed-phrase').value.trim();
  const birthday = parseInt($('birthday').value) || 1687104;

  if (!validate_seed_phrase(seed)) {
    $('wallet-status').textContent = 'invalid seed phrase';
    $('wallet-status').className = 'status err';
    return;
  }

  try {
    state.walletKeys = new WalletKeys(seed);
    state.walletHeight = birthday;
    state.notes = [];
    state.spent = [];

    const addr = state.walletKeys.get_address();
    $('wallet-status').textContent = `imported: ${addr.slice(0,16)}...`;
    $('wallet-status').className = 'status ok';
    $('wallet-height').textContent = birthday.toLocaleString();
    $('remaining').textContent = (state.chainHeight - birthday).toLocaleString();
    $('sync-section').classList.remove('hidden');
    $('balance-section').classList.remove('hidden');

  } catch (e) {
    $('wallet-status').textContent = 'error: ' + e.message;
    $('wallet-status').className = 'status err';
  }
};

// Sync
$('sync-btn').onclick = async () => {
  if (!state.walletKeys || state.scanning) return;

  state.scanning = true;
  $('sync-btn').classList.add('hidden');
  $('stop-btn').classList.remove('hidden');

  const start = state.walletHeight;
  const end = state.chainHeight;
  const total = end - start;

  if (total <= 0) {
    $('sync-status').textContent = 'already synced';
    finishSync();
    return;
  }

  let scanned = 0;
  let actions = 0;
  let found = 0;
  const batchSize = 200;
  const startTime = performance.now();
  let lastVerifyHeight = start;

  $('sync-status').className = 'status active';
  state.verifiedHeight = start;
  state.proofsVerified = 0;

  console.log(`[sync] starting scan from ${start} to ${end} (${total} blocks)`);

  // Show security section and initialize layers
  $('security-section').classList.remove('hidden');
  updateSecurityLayer('ligerito', 'none', 'pending');
  updateSecurityLayer('zanchor', 'none', 'checking...');
  updateSecurityLayer('nomt', 'none', 'pending');

  // Fetch checkpoint to check Zanchor (Polkadot) status
  try {
    const checkpoint = await fetchCheckpoint();
    if (checkpoint && checkpoint.epoch > 0) {
      updateSecurityLayer('zanchor', 'verified', `epoch ${checkpoint.epoch}`);
    } else {
      // No checkpoint yet - parachain may not be connected
      updateSecurityLayer('zanchor', 'unavailable', 'awaiting finality');
    }
  } catch (e) {
    console.warn('[checkpoint] fetch error:', e);
    updateSecurityLayer('zanchor', 'unavailable', 'not connected');
  }

  // Verify gigaproof + tip proof if available (demonstrates ZKP verification)
  if (state.gigaproofHeight > start) {
    const provenTo = Math.min(state.gigaproofHeight, end);
    $('sync-status').textContent = 'verifying proofs...';
    updateSecurityLayer('ligerito', 'active', 'verifying...');

    try {
      // Fetch proofs with public outputs
      const headerProof = await fetchHeaderProof(1, state.gigaproofHeight);
      if (headerProof && headerProof.ligerito_proof && headerProof.ligerito_proof.length > 0) {
        const startVerify = performance.now();
        const ok = await verifyHeaderProof(headerProof);
        const elapsed = ((performance.now() - startVerify) / 1000).toFixed(1);

        if (ok) {
          state.verifiedHeight = provenTo;
          const verifiedPct = ((provenTo - start) / total) * 100;
          $('progress-verified').style.width = verifiedPct + '%';

          // Check continuity between gigaproof and tip proof
          const continuityOk = headerProof.continuity_verified;
          const hasTip = headerProof.tip_proof_outputs !== null;

          // Log public outputs for verification
          if (headerProof.gigaproof_outputs) {
            const go = headerProof.gigaproof_outputs;
            console.log(`[verify] gigaproof: ${go.start_height} -> ${go.end_height}, ${go.num_headers} headers, work=${go.cumulative_difficulty}`);
            console.log(`[verify] gigaproof tip_hash: ${bytesToHex(go.tip_hash?.slice(0, 8) || [])}`);
          }
          if (headerProof.tip_proof_outputs) {
            const to = headerProof.tip_proof_outputs;
            console.log(`[verify] tip_proof: ${to.start_height} -> ${to.end_height}, ${to.num_headers} headers`);
            console.log(`[verify] tip_proof start_prev_hash: ${bytesToHex(to.start_prev_hash?.slice(0, 8) || [])}`);
          }
          console.log(`[verify] continuity_verified: ${continuityOk}`);

          // Show verification status
          let status = `gigaproof verified (${elapsed}s)`;
          if (hasTip) {
            status += continuityOk ? ', tip linked ✓' : ', tip NOT linked ✗';
          }
          $('verified-count').textContent = `verified to ${provenTo.toLocaleString()}`;
          $('sync-status').textContent = status;

          console.log(`[verify] ${status} - covers up to height ${provenTo}`);
          state.proofsVerified++;
          updateSecurityLayer('ligerito', 'verified', continuityOk ? `${elapsed}s ✓` : `${elapsed}s ⚠`);

          // Update NOMT status based on state commitments
          if (headerProof.gigaproof_outputs?.final_state_commitment) {
            updateSecurityLayer('nomt', 'verified', 'state proven');
          }

          // Show proof details panel
          showProofDetails(headerProof);
        } else {
          $('verified-count').textContent = 'verification failed';
          console.warn('[verify] gigaproof verification failed');
          updateSecurityLayer('ligerito', 'unavailable', 'failed');
        }
      } else {
        // No proof available yet, server still generating
        $('verified-count').textContent = 'awaiting proof';
        console.log('[verify] no gigaproof available yet');
        updateSecurityLayer('ligerito', 'active', 'generating...');
      }
    } catch (e) {
      console.warn('[verify] gigaproof fetch/verify error:', e);
      $('verified-count').textContent = 'verify error';
      updateSecurityLayer('ligerito', 'unavailable', 'error');
    }

    // Brief pause to show verification result
    await new Promise(r => setTimeout(r, 500));
  } else {
    updateSecurityLayer('ligerito', 'active', 'generating...');
  }

  for (let h = start; h <= end && state.scanning; h += batchSize) {
    const batchEnd = Math.min(h + batchSize - 1, end);

    try {
      const blocks = await fetchBlocks(h, batchEnd);
      const batchActions = blocks.reduce((sum, b) => sum + b.actions.length, 0);
      if (batchActions > 0) {
        console.log(`[batch ${h}-${batchEnd}] ${blocks.length} blocks, ${batchActions} actions`);
      }

      for (const block of blocks) {
        actions += block.actions.length;

        // Build binary for parallel scan
        if (block.actions.length > 0 && state.walletKeys) {
          const binary = buildBinaryActions(block.actions);
          try {
            const notes = state.walletKeys.scan_actions_parallel(binary);
            if (notes && notes.length > 0) {
              found += notes.length;
              console.log(`[block ${block.height}] found ${notes.length} notes!`, notes);
              for (const n of notes) {
                state.notes.push({ ...n, height: block.height });
              }
            }
          } catch (e) {
            console.warn('scan error at block', block.height, ':', e);
          }
        }

        // Track nullifiers
        for (const a of block.actions) {
          const nf = bytesToHex(a.nullifier);
          if (state.notes.find(n => n.nullifier === nf)) {
            state.spent.push(nf);
          }
        }

        state.walletHeight = block.height;
      }

      scanned += blocks.length;
      const pct = (scanned / total) * 100;
      const elapsed = (performance.now() - startTime) / 1000;
      const rate = Math.round(actions / elapsed);

      // Update sync progress bar
      $('progress').style.width = pct + '%';

      // Update verified progress - gigaproof covers up to gigaproofHeight
      if (state.walletHeight <= state.gigaproofHeight) {
        state.verifiedHeight = state.walletHeight;
        const verifiedPct = ((state.verifiedHeight - start) / total) * 100;
        $('progress-verified').style.width = verifiedPct + '%';
      }

      $('wallet-height').textContent = state.walletHeight.toLocaleString();
      $('remaining').textContent = (end - state.walletHeight).toLocaleString();
      $('verified-count').textContent = state.verifiedHeight >= state.gigaproofHeight ? 'all blocks proven' : `proven to ${state.verifiedHeight.toLocaleString()}`;
      $('sync-status').textContent = `${pct.toFixed(1)}% | ${actions.toLocaleString()} actions (${rate}/s) | ${found} notes`;

    } catch (e) {
      $('sync-status').textContent = 'error: ' + e.message;
      $('sync-status').className = 'status err';
      break;
    }

    await new Promise(r => setTimeout(r, 1));
  }

  // At end, try to verify tip proof for remaining blocks
  if (state.scanning && state.walletHeight > state.gigaproofHeight) {
    $('sync-status').textContent = 'verifying tip proof...';
    try {
      const proof = await fetchHeaderProof(state.gigaproofHeight + 1, state.walletHeight);
      if (proof && proof.length > 0) {
        const ok = await verifyHeaderProof(proof);
        if (ok) {
          state.verifiedHeight = state.walletHeight;
          $('progress-verified').style.width = '100%';
          $('verified-count').textContent = 'all blocks proven';
          state.proofsVerified++;
          console.log(`[verify] tip proof verified!`);
        }
      }
    } catch (e) {
      console.warn('[verify] tip proof failed:', e);
    }
  }

  finishSync();
};

$('stop-btn').onclick = () => {
  state.scanning = false;
};

function finishSync() {
  state.scanning = false;
  $('sync-btn').classList.remove('hidden');
  $('stop-btn').classList.add('hidden');
  $('progress').style.width = '100%';
  $('sync-status').className = 'status ok';

  // Show verification summary
  const verified = state.verifiedHeight >= state.walletHeight;
  const verifyStatus = verified
    ? `fully verified (${state.proofsVerified} zkp)`
    : `verified to ${state.verifiedHeight.toLocaleString()}`;
  $('sync-status').textContent = `sync complete - ${verifyStatus}`;
  $('verified-count').textContent = verifyStatus;

  if (verified) {
    $('progress-verified').style.width = '100%';
  }

  // Update NOMT status - state roots are verified via ligerito proof
  if (state.proofsVerified > 0) {
    updateSecurityLayer('nomt', 'verified', 'roots proven');
  } else {
    updateSecurityLayer('nomt', 'active', 'server attested');
  }

  updateBalance();
}

function updateSecurityLayer(layer, status, detail) {
  state.security[layer] = { status, detail };
  const el = $(`sec-${layer}`);
  const statusEl = $(`sec-${layer}-status`);

  el.classList.remove('active', 'verified', 'unavailable');
  if (status === 'active') el.classList.add('active');
  else if (status === 'verified') el.classList.add('verified');
  else if (status === 'unavailable') el.classList.add('unavailable');

  statusEl.textContent = detail || (status === 'verified' ? '✓' : '-');
}

function showProofDetails(headerProof) {
  const detailsEl = $('proof-details');
  detailsEl.classList.remove('hidden');

  const go = headerProof.gigaproof_outputs;
  const to = headerProof.tip_proof_outputs;

  // Gigaproof range
  if (go) {
    $('proof-giga-range').textContent = `${go.start_height.toLocaleString()} → ${go.end_height.toLocaleString()} (${go.num_headers.toLocaleString()} headers)`;
  }

  // Tip hash (first 16 chars for display)
  if (go?.tip_hash) {
    const tipHashHex = bytesToHex(go.tip_hash);
    $('proof-tip-hash').textContent = tipHashHex.slice(0, 16) + '...';
    $('proof-tip-hash').title = tipHashHex;
  }

  // Chain work (cumulative difficulty)
  if (go?.cumulative_difficulty) {
    const work = go.cumulative_difficulty;
    // Format big number nicely
    const formatted = work > 1000000000000n
      ? `${(Number(work) / 1e12).toFixed(2)}T`
      : work > 1000000000n
      ? `${(Number(work) / 1e9).toFixed(2)}B`
      : work.toLocaleString();
    $('proof-work').textContent = formatted;
  }

  // Continuity verification
  const continuityEl = $('proof-continuity');
  if (to) {
    // We have a tip proof - check if it links to gigaproof
    if (headerProof.continuity_verified) {
      continuityEl.textContent = `✓ giga→tip linked`;
      continuityEl.className = 'value ok';
    } else {
      continuityEl.textContent = `✗ chain break!`;
      continuityEl.className = 'value err';
    }
  } else {
    // No tip proof - gigaproof covers everything
    continuityEl.textContent = 'single proof';
    continuityEl.className = 'value';
  }
}

function updateBalance() {
  const unspent = state.notes.filter(n => !state.spent.includes(n.nullifier));
  const bal = unspent.reduce((sum, n) => sum + BigInt(n.value), 0n);
  $('balance').innerHTML = (Number(bal) / 1e8).toFixed(8) + ' <span>ZEC</span>';

  // Show notes
  const list = $('notes');
  if (state.notes.length === 0) {
    list.innerHTML = '<div style="color: var(--dim); padding: 8px;">no notes found</div>';
  } else {
    list.innerHTML = state.notes.map(n => {
      const spent = state.spent.includes(n.nullifier);
      const val = (Number(n.value) / 1e8).toFixed(8);
      return `<div class="note ${spent ? 'spent' : ''}">
        <span>#${n.height}</span>
        <span class="amount">${spent ? '-' : '+'}${val}</span>
      </div>`;
    }).join('');
  }
}

// gRPC helpers
async function grpc(url, method, data) {
  const path = `${url}/zidecar.v1.Zidecar/${method}`;
  let body;

  if (method === 'GetSyncStatus' || method === 'GetTip') {
    body = new Uint8Array([0, 0, 0, 0, 0]);
  } else {
    throw new Error('unsupported method');
  }

  const resp = await fetch(path, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/grpc-web+proto',
      'Accept': 'application/grpc-web+proto',
      'x-grpc-web': '1',
    },
    body,
  });

  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

  const buf = new Uint8Array(await resp.arrayBuffer());
  if (buf.length < 5) throw new Error('empty response');

  const len = (buf[1] << 24) | (buf[2] << 16) | (buf[3] << 8) | buf[4];
  const msg = buf.slice(5, 5 + len);

  if (method === 'GetSyncStatus') return parseSyncStatus(msg);
  return {};
}

async function fetchBlocks(start, end) {
  const path = `${state.serverUrl}/zidecar.v1.Zidecar/GetCompactBlocks`;
  console.log(`[fetch] requesting blocks ${start}-${end}`);

  // Encode BlockRange
  const parts = [];
  if (start > 0) { parts.push(0x08); parts.push(...varint(start)); }
  if (end > 0) { parts.push(0x10); parts.push(...varint(end)); }
  const msg = new Uint8Array(parts);

  const body = new Uint8Array(5 + msg.length);
  body[0] = 0;
  body[1] = (msg.length >> 24) & 0xff;
  body[2] = (msg.length >> 16) & 0xff;
  body[3] = (msg.length >> 8) & 0xff;
  body[4] = msg.length & 0xff;
  body.set(msg, 5);

  const resp = await fetch(path, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/grpc-web+proto',
      'Accept': 'application/grpc-web+proto',
      'x-grpc-web': '1',
    },
    body,
  });

  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

  const buf = new Uint8Array(await resp.arrayBuffer());
  const blocks = parseBlockStream(buf);
  const totalActions = blocks.reduce((sum, b) => sum + b.actions.length, 0);
  if (totalActions > 0 || blocks.length < 50) {
    console.log(`[fetch] got ${blocks.length} blocks, ${totalActions} total actions`);
  }
  return blocks;
}

function parseBlockStream(buf) {
  const blocks = [];
  let pos = 0;

  while (pos < buf.length) {
    if (pos + 5 > buf.length) break;
    if (buf[pos] === 0x80) break; // trailer

    const len = (buf[pos+1] << 24) | (buf[pos+2] << 16) | (buf[pos+3] << 8) | buf[pos+4];
    pos += 5;
    if (pos + len > buf.length) break;

    blocks.push(parseBlock(buf.slice(pos, pos + len)));
    pos += len;
  }

  return blocks;
}

function parseBlock(buf) {
  const block = { height: 0, hash: new Uint8Array(0), actions: [] };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 0) {
      let v = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        v |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      if (field === 1) block.height = v;
    } else if (wire === 2) {
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 2) block.hash = data;
      else if (field === 3) block.actions.push(parseAction(data));
      pos += len;
    } else break;
  }

  return block;
}

function parseAction(buf) {
  const a = { cmx: new Uint8Array(0), ephemeralKey: new Uint8Array(0), ciphertext: new Uint8Array(0), nullifier: new Uint8Array(0) };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 2) {
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 1) a.cmx = data;
      else if (field === 2) a.ephemeralKey = data;
      else if (field === 3) a.ciphertext = data;
      else if (field === 4) a.nullifier = data;
      pos += len;
    } else break;
  }

  return a;
}

function buildBinaryActions(actions) {
  const size = 32 + 32 + 32 + 52;
  const buf = new Uint8Array(4 + actions.length * size);
  const view = new DataView(buf.buffer);
  view.setUint32(0, actions.length, true);

  let off = 4;
  let valid = 0;
  for (const a of actions) {
    const hasNull = a.nullifier.length === 32;
    const hasCmx = a.cmx.length === 32;
    const hasEpk = a.ephemeralKey.length === 32;
    const hasCt = a.ciphertext.length >= 52;
    if (hasNull && hasCmx && hasEpk && hasCt) valid++;

    if (hasNull) buf.set(a.nullifier, off);
    off += 32;
    if (hasCmx) buf.set(a.cmx, off);
    off += 32;
    if (hasEpk) buf.set(a.ephemeralKey, off);
    off += 32;
    if (hasCt) buf.set(a.ciphertext.slice(0, 52), off);
    off += 52;
  }

  if (valid !== actions.length) {
    console.warn(`[build] only ${valid}/${actions.length} actions are complete`);
  }

  return buf;
}

function parseSyncStatus(buf) {
  const r = { currentHeight: 0, currentEpoch: 0, blocksInEpoch: 0, completeEpochs: 0, gigaproofStatus: 0, lastGigaproofHeight: 0 };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    if ((tag & 0x7) !== 0) break;

    let v = 0, s = 0;
    while (pos < buf.length) {
      const b = buf[pos++];
      v |= (b & 0x7f) << s;
      if (!(b & 0x80)) break;
      s += 7;
    }

    if (field === 1) r.currentHeight = v;
    else if (field === 2) r.currentEpoch = v;
    else if (field === 3) r.blocksInEpoch = v;
    else if (field === 4) r.completeEpochs = v;
    else if (field === 5) r.gigaproofStatus = v;
    else if (field === 7) r.lastGigaproofHeight = v;
  }

  return r;
}

function varint(n) {
  const bytes = [];
  while (n > 127) {
    bytes.push((n & 0x7f) | 0x80);
    n >>>= 7;
  }
  bytes.push(n & 0x7f);
  return bytes;
}

function bytesToHex(bytes) {
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

// Fetch latest FROST checkpoint
async function fetchCheckpoint() {
  const path = `${state.serverUrl}/zidecar.v1.Zidecar/GetCheckpoint`;
  console.log(`[checkpoint] fetching latest checkpoint`);

  // EpochRequest with epoch_index=0 (latest)
  const msg = new Uint8Array([0x08, 0x00]); // field 1, varint 0
  const body = new Uint8Array(5 + msg.length);
  body[0] = 0;
  body[1] = 0; body[2] = 0; body[3] = 0; body[4] = msg.length;
  body.set(msg, 5);

  try {
    const resp = await fetch(path, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/grpc-web+proto',
        'Accept': 'application/grpc-web+proto',
        'x-grpc-web': '1',
      },
      body,
    });

    if (!resp.ok) {
      console.warn(`[checkpoint] HTTP ${resp.status}`);
      return null;
    }

    const buf = new Uint8Array(await resp.arrayBuffer());
    if (buf.length < 5) return null;

    const len = (buf[1] << 24) | (buf[2] << 16) | (buf[3] << 8) | buf[4];
    const msgData = buf.slice(5, 5 + len);

    // Parse FrostCheckpoint - just extract epoch_index (field 1)
    const checkpoint = parseCheckpoint(msgData);
    console.log(`[checkpoint] got checkpoint epoch ${checkpoint.epoch}, height ${checkpoint.height}`);
    return checkpoint;

  } catch (e) {
    console.warn('[checkpoint] fetch failed:', e);
    return null;
  }
}

// Parse FrostCheckpoint protobuf (minimal)
function parseCheckpoint(buf) {
  const cp = { epoch: 0, height: 0, block_hash: null, tree_root: null };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 0) { // varint
      let v = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        v |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      if (field === 1) cp.epoch = v;
      else if (field === 2) cp.height = v;
    } else if (wire === 2) { // length-delimited
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 3) cp.block_hash = data;
      else if (field === 4) cp.tree_root = data;
      pos += len;
    } else {
      break;
    }
  }

  return cp;
}

// Fetch header proof for block range
async function fetchHeaderProof(fromHeight, toHeight) {
  const path = `${state.serverUrl}/zidecar.v1.Zidecar/GetHeaderProof`;
  console.log(`[proof] requesting header proof ${fromHeight}-${toHeight}`);

  // Encode ProofRequest: field 1 = from_height, field 2 = to_height
  const parts = [];
  if (fromHeight > 0) { parts.push(0x08); parts.push(...varint(fromHeight)); }
  if (toHeight > 0) { parts.push(0x10); parts.push(...varint(toHeight)); }
  const msg = new Uint8Array(parts);

  const body = new Uint8Array(5 + msg.length);
  body[0] = 0;
  body[1] = (msg.length >> 24) & 0xff;
  body[2] = (msg.length >> 16) & 0xff;
  body[3] = (msg.length >> 8) & 0xff;
  body[4] = msg.length & 0xff;
  body.set(msg, 5);

  try {
    const resp = await fetch(path, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/grpc-web+proto',
        'Accept': 'application/grpc-web+proto',
        'x-grpc-web': '1',
      },
      body,
    });

    if (!resp.ok) {
      console.warn(`[proof] HTTP ${resp.status}`);
      return null;
    }

    const buf = new Uint8Array(await resp.arrayBuffer());
    if (buf.length < 5) return null;

    // Parse grpc-web frame
    const len = (buf[1] << 24) | (buf[2] << 16) | (buf[3] << 8) | buf[4];
    const msgData = buf.slice(5, 5 + len);

    // Parse HeaderProof - extract ligerito_proof (field 1, wire type 2)
    const proof = parseHeaderProof(msgData);
    console.log(`[proof] got proof: ${proof.ligerito_proof?.length || 0} bytes, range ${proof.from_height}-${proof.to_height}`);
    return proof;

  } catch (e) {
    console.warn('[proof] fetch failed:', e);
    return null;
  }
}

// Parse HeaderProof protobuf (updated with public outputs)
function parseHeaderProof(buf) {
  const proof = {
    ligerito_proof: null,
    from_height: 0,
    to_height: 0,
    tip_hash: null,
    gigaproof_outputs: null,
    tip_proof_outputs: null,
    continuity_verified: false
  };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 0) { // varint
      let v = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        v |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      if (field === 2) proof.from_height = v;
      else if (field === 3) proof.to_height = v;
      else if (field === 8) proof.continuity_verified = (v !== 0);
    } else if (wire === 2) { // length-delimited
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 1) proof.ligerito_proof = data;
      else if (field === 4) proof.tip_hash = data;
      else if (field === 6) proof.gigaproof_outputs = parsePublicOutputs(data);
      else if (field === 7) proof.tip_proof_outputs = parsePublicOutputs(data);
      pos += len;
    } else {
      break; // unknown wire type
    }
  }

  return proof;
}

// Parse ProofPublicOutputs protobuf
function parsePublicOutputs(buf) {
  const outputs = {
    start_height: 0,
    end_height: 0,
    start_hash: null,
    start_prev_hash: null,
    tip_hash: null,
    tip_prev_hash: null,
    cumulative_difficulty: 0n,
    final_commitment: null,
    final_state_commitment: null,
    num_headers: 0
  };
  let pos = 0;

  while (pos < buf.length) {
    const tag = buf[pos++];
    const field = tag >> 3;
    const wire = tag & 0x7;

    if (wire === 0) { // varint
      let v = 0n, s = 0n;
      while (pos < buf.length) {
        const b = BigInt(buf[pos++]);
        v |= (b & 0x7fn) << s;
        if (!(b & 0x80n)) break;
        s += 7n;
      }
      if (field === 1) outputs.start_height = Number(v);
      else if (field === 2) outputs.end_height = Number(v);
      else if (field === 7) outputs.cumulative_difficulty = v;
      else if (field === 10) outputs.num_headers = Number(v);
    } else if (wire === 2) { // length-delimited
      let len = 0, s = 0;
      while (pos < buf.length) {
        const b = buf[pos++];
        len |= (b & 0x7f) << s;
        if (!(b & 0x80)) break;
        s += 7;
      }
      const data = buf.slice(pos, pos + len);
      if (field === 3) outputs.start_hash = data;
      else if (field === 4) outputs.start_prev_hash = data;
      else if (field === 5) outputs.tip_hash = data;
      else if (field === 6) outputs.tip_prev_hash = data;
      else if (field === 8) outputs.final_commitment = data;
      else if (field === 9) outputs.final_state_commitment = data;
      pos += len;
    } else {
      break;
    }
  }

  return outputs;
}

// Verify header proof using ligerito
async function verifyHeaderProof(proof) {
  if (!proof || !proof.ligerito_proof || proof.ligerito_proof.length < 2) {
    console.warn('[verify] no proof to verify');
    return false;
  }

  try {
    // Proof format: [log_size: u8][proof_bytes...]
    const logSize = proof.ligerito_proof[0];
    const proofBytes = proof.ligerito_proof.slice(1);

    console.log(`[verify] verifying proof (${proofBytes.length} bytes, log_size=${logSize})...`);
    const startTime = performance.now();

    // Use the ligerito verify function with config_size and SHA256 transcript
    const result = verifyProof(proofBytes, logSize, "sha256");

    const elapsed = (performance.now() - startTime).toFixed(0);
    console.log(`[verify] result: ${result} (${elapsed}ms)`);
    return result;

  } catch (e) {
    console.warn('[verify] verification failed:', e);
    return false;
  }
}

init();
</script>
</body>
</html>
