syntax = "proto3";
package zidecar.v1;

// Zidecar gRPC service
// Provides Ligerito-proven header chain and trustless state proofs
service Zidecar {
    // Get header chain proof from height range
    rpc GetHeaderProof(ProofRequest) returns (HeaderProof);

    // Stream compact blocks in range
    rpc GetCompactBlocks(BlockRange) returns (stream CompactBlock);

    // Get current chain tip
    rpc GetTip(Empty) returns (BlockId);

    // Subscribe to new blocks (live feed)
    rpc SubscribeBlocks(Empty) returns (stream BlockId);

    // Get sync status (blockchain height, epoch progress, gigaproof status)
    rpc GetSyncStatus(Empty) returns (SyncStatus);

    // Send raw transaction to the network
    rpc SendTransaction(RawTransaction) returns (SendResponse);

    // Get transaction by hash
    rpc GetTransaction(TxFilter) returns (RawTransaction);

    // Get tree state at a given height (for merkle paths)
    rpc GetTreeState(BlockId) returns (TreeState);

    // Get transparent UTXOs for an address
    rpc GetAddressUtxos(TransparentAddressFilter) returns (UtxoList);

    // Get transparent transaction history for addresses
    rpc GetTaddressTxids(TransparentAddressFilter) returns (TxidList);

    // ===== TRUSTLESS STATE PROOFS (v2) =====

    // Get trustless state proof with FROST checkpoint + state transition proof
    // This is the main endpoint for secure sync - proves entire chain state
    rpc GetTrustlessStateProof(ProofRequest) returns (TrustlessStateProof);

    // Get NOMT inclusion proof for a note commitment
    // Proves: cmx is in the commitment tree at position
    rpc GetCommitmentProof(CommitmentQuery) returns (CommitmentProof);

    // Get NOMT proof for nullifier status
    // Proves: nullifier is/isn't in nullifier set
    rpc GetNullifierProof(NullifierQuery) returns (NullifierProof);

    // Get compact blocks with integrity binding
    // Each block includes merkle path proving data matches header
    rpc GetVerifiedBlocks(BlockRange) returns (stream VerifiedBlock);

    // Get FROST checkpoint at epoch boundary
    rpc GetCheckpoint(EpochRequest) returns (FrostCheckpoint);

    // Get epoch boundary hashes for chain continuity verification
    rpc GetEpochBoundary(EpochRequest) returns (EpochBoundary);

    // Get all epoch boundaries in range (for bulk sync)
    rpc GetEpochBoundaries(EpochRangeRequest) returns (EpochBoundaryList);
}

// Request proof for height range
message ProofRequest {
    uint32 from_height = 1;
    uint32 to_height = 2;    // 0 = current tip
}

// Header chain proof with Ligerito
message HeaderProof {
    // Ligerito proof bytes (serialized)
    bytes ligerito_proof = 1;

    // Height range covered
    uint32 from_height = 2;
    uint32 to_height = 3;

    // Chain tip hash
    bytes tip_hash = 4;

    // Block headers for verification
    repeated BlockHeader headers = 5;
}

// Block header metadata
message BlockHeader {
    uint32 height = 1;
    bytes hash = 2;           // 32 bytes
    bytes prev_hash = 3;      // 32 bytes
    uint64 timestamp = 4;
    bytes merkle_root = 5;    // 32 bytes
}

// Block range query
message BlockRange {
    uint32 start_height = 1;
    uint32 end_height = 2;
}

// Compact block (actions only, no tx metadata)
message CompactBlock {
    uint32 height = 1;
    bytes hash = 2;
    repeated CompactAction actions = 3;
}

// Compact Orchard action for trial decryption
message CompactAction {
    bytes cmx = 1;              // note commitment (32 bytes)
    bytes ephemeral_key = 2;    // ephemeral public key (32 bytes)
    bytes ciphertext = 3;       // compact ciphertext (52 bytes)
    bytes nullifier = 4;        // nullifier (32 bytes)
}

// Block identifier
message BlockId {
    uint32 height = 1;
    bytes hash = 2;
}

// Empty message
message Empty {}

// Sync status information
message SyncStatus {
    // Current blockchain height from zcashd
    uint32 current_height = 1;

    // Current epoch number (height / 1024)
    uint32 current_epoch = 2;

    // Blocks in current epoch (0-1023)
    uint32 blocks_in_epoch = 3;

    // Total complete epochs
    uint32 complete_epochs = 4;

    // Gigaproof generation status
    enum GigaproofStatus {
        WAITING_FOR_EPOCH = 0;    // Need more blocks
        GENERATING = 1;            // Currently generating proof
        READY = 2;                 // Gigaproof available
    }
    GigaproofStatus gigaproof_status = 5;

    // Blocks remaining until first gigaproof (0 if ready)
    uint32 blocks_until_ready = 6;

    // Last gigaproof height (0 if none)
    uint32 last_gigaproof_height = 7;
}

// Raw transaction for send/receive
message RawTransaction {
    bytes data = 1;     // raw transaction bytes
    uint32 height = 2;  // block height (0 for unconfirmed)
}

// Response from SendTransaction
message SendResponse {
    string txid = 1;        // transaction hash if successful
    int32 error_code = 2;   // 0 = success
    string error_message = 3;
}

// Filter for GetTransaction
message TxFilter {
    bytes hash = 1;  // 32-byte transaction hash
}

// Tree state at a block height (for building spends)
message TreeState {
    uint32 height = 1;
    bytes hash = 2;                    // block hash
    uint64 time = 3;                   // block timestamp
    string sapling_tree = 4;           // hex-encoded sapling commitment tree
    string orchard_tree = 5;           // hex-encoded orchard commitment tree
}

// Filter for transparent address queries
message TransparentAddressFilter {
    repeated string addresses = 1;     // t-addresses (t1... or t3...)
    uint32 start_height = 2;           // optional start height
    uint32 max_entries = 3;            // optional limit (0 = no limit)
}

// List of transparent UTXOs
message UtxoList {
    repeated Utxo utxos = 1;
}

// Single transparent UTXO
message Utxo {
    string address = 1;         // t-address
    bytes txid = 2;             // 32-byte transaction hash
    uint32 output_index = 3;    // output index in transaction
    bytes script = 4;           // scriptPubKey
    uint64 value_zat = 5;       // value in zatoshis
    uint32 height = 6;          // block height (0 = unconfirmed)
}

// List of transaction IDs
message TxidList {
    repeated bytes txids = 1;   // 32-byte transaction hashes
}

// ===== TRUSTLESS STATE PROOF MESSAGES (v2) =====

// FROST-signed epoch checkpoint (trust anchor)
message FrostCheckpoint {
    // Epoch index (monotonically increasing)
    uint64 epoch_index = 1;

    // Block height at epoch boundary
    uint32 height = 2;

    // Block hash at epoch boundary (32 bytes)
    bytes block_hash = 3;

    // Orchard commitment tree root (32 bytes)
    bytes tree_root = 4;

    // Nullifier set root - NOMT (32 bytes)
    bytes nullifier_root = 5;

    // Unix timestamp of checkpoint
    uint64 timestamp = 6;

    // FROST threshold signature
    FrostSignature signature = 7;

    // Signer set commitment (32 bytes)
    bytes signer_set_id = 8;
}

// FROST Schnorr signature
message FrostSignature {
    bytes r = 1;    // 32 bytes - commitment
    bytes s = 2;    // 32 bytes - response
}

// Request for epoch checkpoint
message EpochRequest {
    uint64 epoch_index = 1;     // 0 = latest
}

// Trustless state proof = FROST checkpoint + ligerito state transition
message TrustlessStateProof {
    // Trust anchor - FROST-signed checkpoint
    FrostCheckpoint checkpoint = 1;

    // Ligerito proof of state transition from checkpoint to current
    bytes state_transition_proof = 2;

    // Current verified state
    uint32 current_height = 3;
    bytes current_hash = 4;          // 32 bytes
    bytes tree_root = 5;             // 32 bytes - commitment tree root
    bytes nullifier_root = 6;        // 32 bytes - nullifier set root

    // Number of Orchard actions processed
    uint64 num_actions = 7;

    // Proof metadata
    uint32 proof_log_size = 8;       // for verifier config selection
}

// Query for commitment inclusion proof
message CommitmentQuery {
    bytes cmx = 1;              // 32-byte note commitment to prove
    uint32 at_height = 2;       // 0 = current height
}

// NOMT inclusion proof for commitment tree
message CommitmentProof {
    bytes cmx = 1;              // the commitment
    uint64 position = 2;        // position in tree
    bytes tree_root = 3;        // tree root this proves against
    uint32 height = 4;          // block height of tree root

    // NOMT merkle proof path
    repeated bytes proof_path = 5;      // sibling hashes
    repeated bool proof_indices = 6;    // left/right indicators

    // Whether commitment exists in tree
    bool exists = 7;
}

// Query for nullifier proof
message NullifierQuery {
    bytes nullifier = 1;        // 32-byte nullifier to check
    uint32 at_height = 2;       // 0 = current height
}

// NOMT proof for nullifier set membership
message NullifierProof {
    bytes nullifier = 1;            // the nullifier
    bytes nullifier_root = 2;       // nullifier set root
    uint32 height = 3;              // block height

    // NOMT sparse merkle proof
    repeated bytes proof_path = 4;
    repeated bool proof_indices = 5;

    // Whether nullifier is spent
    bool is_spent = 6;
}

// Verified compact block with integrity proof
message VerifiedBlock {
    // Standard compact block data
    uint32 height = 1;
    bytes hash = 2;
    repeated CompactAction actions = 3;

    // Integrity binding - proves actions derive from block
    bytes actions_root = 4;         // merkle root of actions
    repeated bytes merkle_path = 5; // path to header merkle root

    // Optional: state after this block
    bytes tree_root_after = 6;      // commitment tree root after block
    bytes nullifier_root_after = 7; // nullifier set root after block
}

// ===== EPOCH BOUNDARY MESSAGES =====

// Epoch boundary hashes for chain continuity verification
message EpochBoundary {
    // Epoch index
    uint32 epoch = 1;

    // First block of epoch
    uint32 first_height = 2;
    bytes first_hash = 3;           // 32 bytes
    bytes first_prev_hash = 4;      // 32 bytes - links to previous epoch

    // Last block of epoch
    uint32 last_height = 5;
    bytes last_hash = 6;            // 32 bytes
}

// Request for epoch range
message EpochRangeRequest {
    uint32 from_epoch = 1;
    uint32 to_epoch = 2;            // 0 = latest
}

// List of epoch boundaries
message EpochBoundaryList {
    repeated EpochBoundary boundaries = 1;
}
